<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tabela Virtual Mitra</title>
  <style>
    /* Fonte e reset básico */
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
    :root {
      --th-divider: #E5E7EB;
      --totalizer-bg: #F8F9FA;
      --totalizer-font-size: 13px;
      --totalizer-font-weight: 600;
      --totalizer-label-color: #09090b;
      --totalizer-value-color: #09090b;
      --border-color: #E5E7EB;
      --text-primary: #1B2139;
      --text-secondary: #5D6585;
      --bg-surface: #FFFFFF;
      --bg-hover: #FAFAFA;
      --bg-header: #fbfcff;
      --shadow-soft: 0 1px 2px rgba(0,0,0,0.04);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      font-family: 'Inter', sans-serif;
      background: #f7f7f9;
      color: var(--text-primary);
    }
    .form-wrapper {
      max-width: 100%;
      margin: 0 auto;
      background: var(--bg-surface);
      border: 1px solid #D0D5DD;
      border-radius: 16px;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      box-shadow: var(--shadow-soft);
      overflow: hidden;
    }
    .header {
      padding: 24px;
      border-bottom: 1px solid var(--border-color);
      background: var(--bg-surface);
      position: sticky;
      top: 0;
      z-index: 30;
    }
    .header h2 {
      margin: 0 0 6px;
      font-size: 18px;
      font-weight: 600;
    }
    .header p {
      margin: 0;
      font-size: 14px;
      color: var(--text-secondary);
    }
    .header-actions {
      margin-top: 16px;
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
    }
    .search-box {
      position: relative;
      flex: 1 1 320px;
      min-width: 240px;
    }
    .search-box input {
      width: 100%;
      height: 38px;
      padding: 0 12px 0 36px;
      border: 1px solid #E7E8F0;
      border-radius: 10px;
      font-size: 14px;
      color: var(--text-secondary);
      outline: none;
    }
    .search-icon {
      position: absolute;
      left: 12px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 16px;
      color: #5D6585;
    }
    .header-buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }
    .btn {
      border: 1px solid #D0D5DD;
      background: #fff;
      color: #1B2139;
      padding: 8px 12px;
      border-radius: 10px;
      font-size: 13px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: background-color 0.15s ease, opacity 0.15s ease;
    }
    .btn:hover { background: #f3f4f6; }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn-ghost {
      border: 1px solid #D0D5DD;
      background: #fff;
    }
    .btn-danger {
      background: #ef4444;
      color: #fff;
      border: 1px solid #ef4444;
    }
    .table-container {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      min-height: 0;
      padding: 0 24px 24px;
    }
    .table-scroll {
      position: relative;
      border: 1px solid var(--border-color);
      border-radius: 12px;
      overflow: auto;
      min-height: 320px;
      background: #fff;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      table-layout: fixed;
      min-width: max-content;
    }
    thead {
      position: sticky;
      top: 0;
      z-index: 10;
      background: var(--bg-header);
      box-shadow: inset 0 -1px 0 #e5e7eb;
    }
    th, td {
      padding: 8px;
      font-size: 13px;
      border: none;
      color: #111827;
    }
    th {
      font-weight: 600;
      color: #374151;
      text-align: left;
      user-select: none;
    }
    tr.data-row:hover, tr.classic-row:hover {
      background: var(--bg-hover);
    }
    .no-hover:hover { background: inherit !important; }
    .cell-center { text-align: center; }
    .cell-right { text-align: right; }
    .cell-left { text-align: left; }
    .icon-circle {
      width: 28px;
      height: 28px;
      border-radius: 9999px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      border: 1px solid #E7E8F0;
    }
    .avatar-img {
      width: 28px;
      height: 28px;
      object-fit: cover;
      border-radius: inherit;
    }
    .alert-dot {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 9999px;
      margin-left: 6px;
    }
    .totalizer {
      position: sticky;
      bottom: 0;
      z-index: 20;
      background: var(--totalizer-bg);
      box-shadow: inset 0 1px 0 #E5E7EB;
    }
    .totalizer td {
      font-size: var(--totalizer-font-size);
      font-weight: var(--totalizer-font-weight);
      color: var(--totalizer-value-color);
      padding: 8px;
    }
    .spacer {
      width: 100%;
    }
    .loading-overlay {
      position: absolute;
      inset: 0;
      background: rgba(255,255,255,0.85);
      backdrop-filter: blur(1px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 40;
      flex-direction: column;
      gap: 10px;
      color: #5d6585;
      font-size: 14px;
    }
    .loading-overlay.show { display: flex; }
    .spinner {
      width: 32px;
      height: 32px;
      border: 3px solid #e5e7eb;
      border-top-color: #5d6585;
      border-radius: 9999px;
      animation: spin 0.8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    /* Pivô */
    .subheader-top { background: #F4F4F5; box-shadow: inset 0 -1px 0 #e5e7eb; }
    .subheader-bottom { background: #FAFAFA; box-shadow: inset 0 -1px 0 #e5e7eb; }
    .vdiv-row > th { position: relative; }
    .vdiv-row > th:not(:last-child)::after {
      content: "";
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      width: 1px;
      background: var(--th-divider);
      pointer-events: none;
      z-index: 1;
    }
    .tag {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 6px;
      border-radius: 9999px;
      background: #f3f4f6;
      color: #111827;
      font-size: 12px;
      border: 1px solid #e5e7eb;
    }
    .checkbox {
      width: 16px;
      height: 16px;
      border: 1px solid #CBD5E1;
      border-radius: 4px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: #fff;
      cursor: pointer;
    }
    .checkbox.checked { background: #2563eb; border-color: #2563eb; color: #fff; }
    .input {
      width: 100%;
      height: 30px;
      padding: 0 8px;
      border: 1px solid #E5E7EB;
      border-radius: 8px;
      font-size: 13px;
      color: #111827;
      outline: none;
    }
    .select {
      width: 100%;
      height: 32px;
      border: 1px solid #E5E7EB;
      border-radius: 8px;
      font-size: 13px;
      color: #111827;
      background: #fff;
      outline: none;
      padding: 0 8px;
    }
    .pill {
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid #e5e7eb;
      background: #f3f4f6;
      font-size: 12px;
    }
    .empty-state {
      padding: 24px;
      text-align: center;
      color: #5D6585;
    }
  </style>
</head>
<body>
  <div class="form-wrapper">
    <div class="header">
      <h2 id="title">Carregando...</h2>
      <p id="subtitle">Aguarde enquanto os dados são carregados.</p>
      <div class="header-actions">
        <div class="search-box" id="search-box">
          <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
          <input id="search-input" type="text" placeholder="Buscar..." autocomplete="off">
        </div>
        <div class="header-buttons" id="header-buttons"></div>
      </div>
    </div>

    <div class="table-container">
      <div class="table-scroll" id="table-scroll">
        <div class="loading-overlay" id="loading-overlay">
          <div class="spinner"></div>
          <span>Carregando dados...</span>
        </div>
        <div class="spacer" id="spacer-top"></div>
        <table>
          <thead id="table-head"></thead>
          <tbody id="table-body"></tbody>
          <tfoot id="table-foot"></tfoot>
        </table>
        <div class="spacer" id="spacer-bottom"></div>
      </div>
    </div>
  </div>

  <script>
    // Declarações Mitra
    /** @type {(options:{query:string,jdbcId?:number})=>Promise<{headers:{name:string,dataType?:string}[],data:any[][]}>} */
    const queryMitra = window.queryMitra;
    /** @type {(variable:{name:string,content:any})=>Promise<void>} */
    const setVariableMitra = window.setVariableMitra || (async () => {});
    /** @type {(id:number|{id:number})=>Promise<void>} */
    const dbactionMitra = window.dbactionMitra || (async () => {});
    /** @type {(options:{id:number,contentId?:any})=>Promise<void>|void} */
    const formMitra = window.formMitra || (() => {});
    /** @type {(options:{id:number,width?:number,height?:number,reload?:boolean,floating?:boolean})=>void} */
    const modalMitra = window.modalMitra || (() => {});
    /** @type {(options:{id:number})=>Promise<void>} */
    const actionMitra = window.actionMitra || (async () => {});
    /** @type {(opts?:any)=>void} */
    const updateComponentsMitra = window.updateComponentsMitra || (() => {});

    // Utilidades
    const safeJSONParse = (val, fallback) => {
      if (val === undefined || val === null || val === "") return fallback;
      try { return JSON.parse(val); } catch { return fallback; }
    };
    const formatNumberBR = (value) => typeof value === "number"
      ? new Intl.NumberFormat("pt-BR").format(value)
      : value;
    const parseNumberBR = (str) => {
      if (!str && str !== 0) return NaN;
      return parseFloat(String(str).replace(/\./g, "").replace(",", "."));
    };
    const roundN = (n, p) => {
      if (!isFinite(n)) return NaN;
      const f = Math.pow(10, p);
      return Math.round(n * f) / f;
    };
    const formatNumberBRN = (value, places) => {
      const num = typeof value === "number" ? value : parseNumberBR(String(value));
      if (!isFinite(num)) return "";
      if (places === 0) {
        return new Intl.NumberFormat("pt-BR", { maximumFractionDigits: 0, useGrouping: false }).format(Math.trunc(num));
      }
      return new Intl.NumberFormat("pt-BR", { minimumFractionDigits: places, maximumFractionDigits: places }).format(roundN(num, places));
    };
    const parseToYYYYMMDD = (dateStr, customFormat) => {
      if (!dateStr) return "";
      const trimmed = String(dateStr).trim();
      if (customFormat) {
        // parsing simples via regex (evita dependência externa)
        const parts = trimmed.match(/(\d{2})\/(\d{2})\/(\d{4})/);
        if (parts) {
          const [_, d, m, y] = parts;
          return `${y}-${m}-${d}`;
        }
      }
      const d = new Date(trimmed);
      if (!isNaN(d.getTime())) return d.toISOString().split("T")[0];
      return "";
    };
    const getIconComponent = (name) => {
      if (!name) return "HelpCircle";
      const map = {
        "delete": "Trash2", "trash": "Trash2",
        "view": "Eye", "copy": "Share", "share": "Share",
        "close": "X", "cancel": "X", "arrow-down": "ArrowDown",
        "arrowup": "ArrowUp", "arrow-up": "ArrowUp",
        "warning": "AlertTriangle", "error": "AlertCircle",
        "file": "FileText", "eye-off": "EyeOff",
        "help": "HelpCircle", "alert-circle": "AlertCircle",
        "image-off": "ImageOff", "no-image": "ImageOff",
      };
      const normalized = name.trim().toLowerCase();
      if (map[normalized]) return map[normalized];
      if (/^[A-Z][a-zA-Z0-9]+$/.test(name)) return name;
      const pascal = normalized.split(/[-_\s]/).map(p => p.charAt(0).toUpperCase() + p.slice(1)).join("");
      return pascal || "HelpCircle";
    };
    const resolveAlertVisual = (colDef, rawValue) => {
      const cfg = colDef?.alertConfig;
      if (!cfg || !cfg.type || !Array.isArray(cfg.rules)) return null;
      const valStr = String(rawValue ?? "").trim();
      const valNum = Number(valStr);
      const isNum = !isNaN(valNum) && isFinite(valNum);
      const hit = cfg.rules.find(r => {
        const rStr = String(r.match).trim();
        if (rStr === valStr) return true;
        const rNum = Number(rStr);
        if (!isNaN(rNum) && isFinite(rNum) && isNum) return rNum === valNum;
        return false;
      });
      if (hit) return { type: cfg.type, color: hit.color };
      if (cfg.elseColor) return { type: cfg.type, color: cfg.elseColor };
      return null;
    };
    const wrapCellWithAlert = (inner, alert, opts) => {
      if (!alert) return inner;
      const invasiveOnInputs = opts?.invasiveOnInputs || false;
      if (alert.type === "dot") {
        const dot = document.createElement("span");
        dot.className = "alert-dot";
        dot.style.backgroundColor = alert.color;
        const wrapper = document.createElement("div");
        wrapper.style.display = "flex";
        wrapper.style.alignItems = "center";
        wrapper.style.gap = "4px";
        wrapper.appendChild(inner);
        wrapper.appendChild(dot);
        return wrapper;
      }
      if (!invasiveOnInputs) return inner;
      if (alert.type === "bg") {
        const wrapper = document.createElement("div");
        wrapper.style.backgroundColor = alert.color;
        wrapper.style.padding = "4px 6px";
        wrapper.appendChild(inner);
        return wrapper;
      }
      if (alert.type === "text") {
        inner.style.color = alert.color;
        return inner;
      }
      return inner;
    };
    const deriveHeaderClass = (col) => {
      if (col.headerAlignment) return `cell-${col.headerAlignment}`;
      const idRegex = /(^id$)|(^id_)|(_id$)/i;
      const isId = idRegex.test(col.columnName || "") || idRegex.test(col.dataField || "");
      if (col.columnType === "data_number") return isId ? "cell-left" : "cell-right";
      if (["input_date","data_boolean_checkbox","action_button","action_buttons_group","input_text","input_number","input_dropdown","data_iconphoto"].includes(col.columnType)) return "cell-center";
      return "cell-left";
    };
    const deriveCellClass = (col) => {
      if (col.cellAlignment) return `cell-${col.cellAlignment}`;
      return deriveHeaderClass(col);
    };
    const waitIndefinitely = (promise) => new Promise((resolve, reject) => {
      const attempt = async () => {
        try { resolve(await promise); }
        catch (err) {
          const msg = String(err?.message || err || "").toLowerCase();
          if (msg.includes("timeout") || msg.includes("aguardar resposta da interação")) {
            console.warn("Timeout ignorado, aguardando indefinidamente a resposta do form...");
            setTimeout(attempt, 1000);
          } else reject(err);
        }
      };
      attempt();
    });
    const safeModalMitra = (opts) => {
      const defaultW = parseTamanhoModal.width || 100;
      const defaultH = parseTamanhoModal.height || 100;
      modalMitra({
        id: opts.id,
        width: opts.width ?? defaultW,
        height: opts.height ?? defaultH,
        reload: opts.reload ?? false,
        floating: opts.floating ?? false,
      });
    };

    // Estado principal
    const STATE = {
      config: {},
      baseColumns: [],
      dynamicOptionsMap: {},
      headerLUT: {},
      headerButtons: [],
      data: [],
      filtered: [],
      queryTotals: {},
      loading: false,
      searchTerm: "",
      sortState: { columnId: null, dir: null, isPivot: false, pivotGroupKey: null, pivotDetailKey: null },
      xAxisGroupSort: null,
      lastSentSearch: "",
    };

    // Referências DOM
    const refs = {
      title: document.getElementById("title"),
      subtitle: document.getElementById("subtitle"),
      searchInput: document.getElementById("search-input"),
      headerButtons: document.getElementById("header-buttons"),
      tableHead: document.getElementById("table-head"),
      tableBody: document.getElementById("table-body"),
      tableFoot: document.getElementById("table-foot"),
      spacerTop: document.getElementById("spacer-top"),
      spacerBottom: document.getElementById("spacer-bottom"),
      scroll: document.getElementById("table-scroll"),
      loading: document.getElementById("loading-overlay"),
      searchBox: document.getElementById("search-box"),
    };

    const VIRTUAL_SCROLL = {
      rowHeight: 44,
      buffer: 10,
      visible: 0,
      scrollTop: 0,
      rafId: null,
    };

    // Configurações derivadas de componentData
    const parseTamanhoModal = (() => {
      const raw = window.componentData?.tamanhoModal;
      if (typeof raw === "string" && /^\d+:\d+$/.test(raw)) {
        const [w, h] = raw.split(":").map(Number);
        return { width: w, height: h };
      }
      return { width: 100, height: 100 };
    })();

    const MODAL_RELOAD_BEHAVIOR = window.componentData?.closeModalOnReload === true || window.componentData?.closeModalOnReload === "true";
    const LIVE_SEARCH = true;

    // Parsing do componentData
    function parseComponentData() {
      const cd = window.componentData || {};
      const columnsRaw = cd.columns;
      let parsedColumns = [];
      try {
        parsedColumns = Array.isArray(columnsRaw)
          ? columnsRaw
          : (typeof columnsRaw === "string" && columnsRaw.trim() !== "" ? JSON.parse(columnsRaw) : []);
      } catch (e) {
        console.error("A variável 'columns' está inválida:", e);
        parsedColumns = [];
      }

      // IconPhoto configs
      let iconPhotoColumns = [];
      if (cd.iconPhotoColumnsConfig) {
        try {
          const parsed = typeof cd.iconPhotoColumnsConfig === "string"
            ? JSON.parse(cd.iconPhotoColumnsConfig)
            : cd.iconPhotoColumnsConfig;
          if (Array.isArray(parsed)) {
            iconPhotoColumns = parsed.map(config => ({
              ...config,
              columnType: "data_iconphoto",
              dataField: config.columnName,
              headerName: config.headerName || config.columnName,
              width: config.width || "60px",
              cellAlignment: "center",
              headerAlignment: "center",
              enableSorting: false,
              enableHiding: true,
              imageShape: config.imageShape || 'circle',
              __isIconColumn: true,
              position: config.position !== undefined && config.position !== "" ? Number(config.position) : undefined,
            }));
          }
        } catch (e) {
          console.error("iconPhotoColumnsConfig inválido:", e);
        }
      }

      // Combina colunas de conteúdo
      const contentColumns = [...parsedColumns, ...iconPhotoColumns].map((c, idx) => ({
        ...c,
        __originalIndex: idx,
        position: c.position !== undefined && c.position !== "" ? Number(c.position) : undefined,
      }));

      // Ordenação por posição manual (1-based) preenchendo buracos
      const positioned = [];
      const nonPos = [];
      for (const col of contentColumns) {
        if (col.position !== undefined) positioned[col.position - 1] = col;
        else nonPos.push(col);
      }
      for (let i = 0; i < positioned.length + nonPos.length; i++) {
        if (!positioned[i]) {
          const next = nonPos.shift();
          if (next) positioned[i] = next;
        }
      }
      const baseColumnJSON = positioned.filter(Boolean).map(c => {
        const copy = { ...c };
        delete copy.__originalIndex;
        return copy;
      });

      // Botão grupo de ações
      let buttonsGroupConfig = null;
      try {
        const rawBGC = cd.buttonsGroupConfig;
        if (rawBGC && String(rawBGC).trim() !== "") {
          let parsed = rawBGC;
          if (typeof rawBGC === "string") {
            try { parsed = JSON.parse(rawBGC.trim()); }
            catch { parsed = eval(`(${rawBGC})`); }
          }
          if (Array.isArray(parsed)) {
            buttonsGroupConfig = {
              setRowIdVariable: cd.setRowIdVariableBotaoGrupo || "ID",
              buttons: parsed,
            };
          }
        }
      } catch (e) {
        console.warn("buttonsGroupConfig inválido, ignorado.");
      }
      if (buttonsGroupConfig) {
        baseColumnJSON.push({
          columnName: "Ações",
          dataField: "__actions__",
          columnType: "action_buttons_group",
          headerName: "Ações",
          cellAlignment: "center",
          headerAlignment: "center",
          enableSorting: false,
          enableHiding: false,
          width: "140px",
          buttonsGroupConfig,
        });
      }

      STATE.baseColumns = baseColumnJSON;
      STATE.config = {
        query: cd.query,
        jdbcId: Number(cd.jdbcId) > 0 ? Number(cd.jdbcId) : 1,
        title: cd.title || "Tabela de Dados",
        subtitle: cd.subtitle || "Visualize e filtre os registros abaixo.",
        tableDesign: (cd.tableDesign || "classic").toLowerCase(),
        showBorder: cd.showBorder !== "false",
        variableSearch: (cd.variableSearch || "").toString().trim(),
        enableSearch: cd.enableSearch === true || cd.enableSearch === "true",
        xAxisFkColumn: (cd.xAxisFkColumn || "").toString().trim(),
        xAxisLabelColumn: (cd.xAxisLabelColumn || "").toString().trim(),
        xAxisRowKeyColumn: (cd.xAxisRowKeyColumn || "").toString().trim(),
        xAxisFixedColumns: (() => { try { return Array.isArray(cd.xAxisFixedColumns) ? cd.xAxisFixedColumns : JSON.parse(String(cd.xAxisFixedColumns || "[]")); } catch { return String(cd.xAxisFixedColumns || "").split(",").filter(Boolean); } })(),
        xAxisDetailColumns: (() => { try { return Array.isArray(cd.xAxisDetailColumns) ? cd.xAxisDetailColumns : JSON.parse(String(cd.xAxisDetailColumns || "[]")); } catch { return String(cd.xAxisDetailColumns || "").split(",").filter(Boolean); } })(),
        headerButtons: cd.headerButtons,
        headerButtonsQuery: cd.headerButtonsQuery,
        tamanhoModal: parseTamanhoModal,
        closeModalOnReload: MODAL_RELOAD_BEHAVIOR,
        liveSearch: true,
      };
      refs.title.textContent = STATE.config.title;
      refs.subtitle.textContent = STATE.config.subtitle;
      if (!STATE.config.enableSearch) {
        refs.searchBox.style.display = "none";
      }
    }

    // Header LUT (case-insensitive)
    function buildHeaderLUT(headers) {
      const lut = {};
      (headers || []).forEach(h => {
        const nm = String(h?.name ?? "");
        if (nm) lut[nm.toLowerCase()] = nm;
      });
      STATE.headerLUT = lut;
    }
    const resolveKey = (k) => {
      if (!k || typeof k !== "string") return "";
      return STATE.headerLUT[k.toLowerCase()] ?? k;
    };
    const getCI = (obj, k) => {
      const actual = resolveKey(k);
      return actual ? obj?.[actual] : undefined;
    };

    // Transformação de dados Mitra
    function transformMitraData(res) {
      const booleanColumns = STATE.baseColumns
        .filter(col => col.columnType === "data_boolean_checkbox")
        .map(col => col.dataField);
      return (res.data || []).map(row =>
        (res.headers || []).reduce((obj, h, idx) => {
          const value = row[idx];
          const isBoolean = booleanColumns.includes(h.name);
          obj[h.name] = isBoolean
            ? (value === true || value === 1 || value === "1" || value === "true")
            : value;
          return obj;
        }, {})
      );
    }

    // Dropdown options dinâmicas
    async function fetchDropdownOptions() {
      const map = {};
      const dcols = STATE.baseColumns.filter(c => c.columnType === "input_dropdown" && c.dropdownOptionsWithQuery);
      await Promise.all(dcols.map(async col => {
        try {
          const res = await queryMitra({ query: col.dropdownOptionsWithQuery, jdbcId: STATE.config.jdbcId });
          map[resolveKey(String(col.dataField))] = res.data.map(r => ({
            value: r[0],
            label: r[1] !== undefined ? r[1] : r[0],
          }));
        } catch (err) {
          console.error(`Erro ao carregar opções de ${col.columnName}:`, err);
        }
      }));
      STATE.dynamicOptionsMap = map;
    }

    // Totalizadores
    async function fetchTotalizerData() {
      const totalCols = STATE.baseColumns.filter(c => typeof c.enableTotalizer === "string" && c.enableTotalizer.trim() !== "");
      if (totalCols.length === 0) {
        STATE.queryTotals = {};
        return;
      }
      const results = await Promise.all(totalCols.map(async col => {
        const key = resolveKey(col.dataField);
        try {
          const res = await queryMitra({ query: col.enableTotalizer, jdbcId: STATE.config.jdbcId });
          if (!Array.isArray(res?.data) || res.data.length !== 1 || !Array.isArray(res.data[0]) || res.data[0].length !== 1) {
            console.warn(`[enableTotalizer] Query da coluna "${col.columnName}" precisa retornar 1x1. Ignorada.`);
            return { key, value: null };
          }
          return { key, value: res.data[0][0] };
        } catch (e) {
          console.error(`Erro totalizador "${col.columnName}":`, e);
          return { key, value: null };
        }
      }));
      const totals = {};
      results.forEach(r => { if (r.key) totals[r.key] = r.value; });
      STATE.queryTotals = totals;
    }

    // Botões de cabeçalho
    async function fetchHeaderButtons() {
      const template = (() => {
        try {
          const raw = STATE.config.headerButtons;
          return typeof raw === "string" ? JSON.parse(raw) : (Array.isArray(raw) ? raw : []);
        } catch (e) {
          console.error("headerButtons inválido:", e);
          return [];
        }
      })();
      const query = STATE.config.headerButtonsQuery;
      if (!query) {
        STATE.headerButtons = template.filter(btn => btn && btn.interaction);
        return;
      }
      if (!template || template.length === 0) {
        STATE.headerButtons = [];
        return;
      }
      try {
        const res = await queryMitra({ query, jdbcId: STATE.config.jdbcId });
        if (!res.data || res.data.length === 0) {
          STATE.headerButtons = [];
          return;
        }
        const interactionData = res.headers.reduce((obj, header, idx) => {
          obj[header.name] = res.data[0][idx];
          return obj;
        }, {});
        STATE.headerButtons = template.map(btn => {
          const interaction = interactionData[btn.interactionColumn];
          if (!interaction) return null;
          return { ...btn, interaction };
        }).filter(Boolean);
      } catch (e) {
        console.error("Erro ao executar headerButtonsQuery:", e);
        STATE.headerButtons = [];
      }
    }

    // Busca e ordenação
    function applyFiltersAndSort() {
      const term = (STATE.searchTerm || "").toLowerCase();
      const data = [...STATE.data];
      let filtered = data;
      if (STATE.config.enableSearch && term) {
        filtered = data.filter(row => {
          return Object.entries(row).some(([field, value]) => {
            if (String(value ?? "").toLowerCase().includes(term)) return true;
            const opts = STATE.dynamicOptionsMap[field];
            if (opts) {
              const opt = opts.find(o => String(o.value) === String(value));
              if (opt && String(opt.label).toLowerCase().includes(term)) return true;
            }
            return false;
          });
        });
      }
      // Ordenação
      const ss = STATE.sortState;
      if (ss.columnId) {
        const colDef = STATE.baseColumns.find(c => resolveKey(c.dataField) === ss.columnId);
        if (colDef) {
          const isNumber = colDef.columnType === "data_number" || colDef.columnType === "input_number";
          const isDate = colDef.columnType === "input_date" || /data|date/i.test(String(colDef.columnName || colDef.dataField || ""));
          const toComparable = (v) => {
            if (v == null) return null;
            if (isNumber) {
              const n = typeof v === "number" ? v : parseNumberBR(String(v));
              return isNaN(n) ? null : n;
            }
            if (isDate) {
              const ts = Date.parse(v);
              return isNaN(ts) ? null : ts;
            }
            return String(v);
          };
          filtered.sort((a, b) => {
            const av = toComparable(a[ss.columnId]);
            const bv = toComparable(b[ss.columnId]);
            if (av === null && bv === null) return 0;
            if (av === null) return 1;
            if (bv === null) return -1;
            if (av === bv) return 0;
            const cmp = av > bv ? 1 : -1;
            return ss.dir === "asc" ? cmp : -cmp;
          });
        }
      }
      STATE.filtered = filtered;
    }

    // Renderização de header (padrão e pivô)
    function renderHeader() {
      const thead = refs.tableHead;
      thead.innerHTML = "";
      const hasPivot = !!STATE.config.xAxisFkColumn && !!STATE.config.xAxisRowKeyColumn;
      if (!hasPivot) {
        const tr = document.createElement("tr");
        tr.className = "no-hover";
        STATE.baseColumns.forEach(col => {
          const th = document.createElement("th");
          th.textContent = col.headerName || col.columnName;
          th.className = deriveHeaderClass(col);
          th.style.width = col.width || "130px";
          th.style.minWidth = th.style.width;
          th.style.maxWidth = th.style.width;
          const sortIcon = document.createElement("span");
          sortIcon.style.marginLeft = "6px";
          sortIcon.style.fontSize = "11px";
          if (col.enableSorting !== false) {
            th.style.cursor = "pointer";
            th.onclick = () => cycleSort(col);
            const isActive = STATE.sortState.columnId === resolveKey(col.dataField);
            sortIcon.textContent = isActive ? (STATE.sortState.dir === "asc" ? "▲" : "▼") : "⇅";
            sortIcon.style.opacity = isActive ? "1" : "0.4";
          }
          th.appendChild(sortIcon);
          tr.appendChild(th);
        });
        thead.appendChild(tr);
        return;
      }

      // Pivô: cabeçalhos em duas linhas (grupos)
      const fkKey = resolveKey(STATE.config.xAxisFkColumn);
      const labelKey = STATE.config.xAxisLabelColumn ? resolveKey(STATE.config.xAxisLabelColumn) : fkKey;
      const fixedKeys = STATE.config.xAxisFixedColumns.map(resolveKey).filter(Boolean);
      const detailKeys = (STATE.config.xAxisDetailColumns || []).map(resolveKey).filter(Boolean);

      // Descobre grupos visíveis
      const visibleRows = STATE.filtered || [];
      const groupMap = new Map();
      for (const r of visibleRows) {
        const gv = r[fkKey];
        const label = r[labelKey] ?? gv;
        const k = String(gv ?? "");
        if (!groupMap.has(k)) groupMap.set(k, { key: gv, label });
      }
      const groups = Array.from(groupMap.values());

      // Linha 1
      const tr1 = document.createElement("tr");
      tr1.className = "no-hover subheader-top vdiv-row";
      const thFixed = document.createElement("th");
      thFixed.colSpan = Math.max(fixedKeys.length, 1);
      thFixed.textContent = "";
      tr1.appendChild(thFixed);
      groups.forEach(g => {
        const th = document.createElement("th");
        th.colSpan = detailKeys.length || 1;
        th.className = "cell-center";
        th.textContent = String(g.label ?? g.key ?? "");
        tr1.appendChild(th);
      });
      thead.appendChild(tr1);

      // Linha 2
      const tr2 = document.createElement("tr");
      tr2.className = "no-hover subheader-bottom vdiv-row";
      const createHeaderCell = (colKey, label, width, colDef) => {
        const th = document.createElement("th");
        th.textContent = label;
        th.className = deriveHeaderClass(colDef || {});
        th.style.width = width || "130px";
        th.style.minWidth = th.style.width;
        th.style.maxWidth = th.style.width;
        const sortIcon = document.createElement("span");
        sortIcon.style.marginLeft = "6px";
        sortIcon.style.fontSize = "11px";
        th.style.cursor = "pointer";
        th.onclick = () => cycleSort(colDef || { dataField: colKey, columnType: "data_text" }, true, { groupKey: null, detailKey: colKey });
        const isActive = STATE.sortState.columnId === colKey && STATE.sortState.isPivot === false;
        sortIcon.textContent = isActive ? (STATE.sortState.dir === "asc" ? "▲" : "▼") : "⇅";
        sortIcon.style.opacity = isActive ? "1" : "0.4";
        th.appendChild(sortIcon);
        return th;
      };
      fixedKeys.forEach(k => {
        const def = STATE.baseColumns.find(c => resolveKey(c.dataField) === k);
        tr2.appendChild(createHeaderCell(k, def?.headerName || def?.columnName || k, def?.width, def));
      });
      if (fixedKeys.length === 0) tr2.appendChild(createHeaderCell("__void__", "", "80px", {}));
      groups.forEach(g => {
        (detailKeys.length ? detailKeys : ["__detail__"]).forEach(dk => {
          const def = STATE.baseColumns.find(c => resolveKey(c.dataField) === dk);
          const th = document.createElement("th");
          th.className = deriveHeaderClass(def || {});
          th.style.width = def?.width || "130px";
          th.style.minWidth = th.style.width;
          th.style.maxWidth = th.style.width;
          th.style.cursor = "pointer";
          const isActive = STATE.sortState.isPivot && STATE.sortState.pivotGroupKey === g.key && STATE.sortState.pivotDetailKey === dk;
          th.onclick = () => cycleSort(def || { dataField: dk, columnType: "data_text" }, true, { groupKey: g.key, detailKey: dk });
          const span = document.createElement("span");
          span.textContent = def?.headerName || def?.columnName || dk;
          const icon = document.createElement("span");
          icon.style.marginLeft = "6px";
          icon.style.fontSize = "11px";
          icon.textContent = isActive ? (STATE.sortState.dir === "asc" ? "▲" : "▼") : "⇅";
          icon.style.opacity = isActive ? "1" : "0.4";
          th.appendChild(span);
          th.appendChild(icon);
          tr2.appendChild(th);
        });
      });
      thead.appendChild(tr2);
    }

    function cycleSort(colDef, isPivot = false, pivotInfo = {}) {
      const colId = resolveKey(colDef.dataField);
      const current = STATE.sortState;
      let dir = "asc";
      if (current.columnId === colId && current.dir === "asc") dir = "desc";
      else if (current.columnId === colId && current.dir === "desc") dir = null;
      if (!dir) {
        STATE.sortState = { columnId: null, dir: null, isPivot: false, pivotGroupKey: null, pivotDetailKey: null };
      } else {
        STATE.sortState = {
          columnId: colId,
          dir,
          isPivot: !!isPivot,
          pivotGroupKey: pivotInfo.groupKey || null,
          pivotDetailKey: pivotInfo.detailKey || null,
        };
      }
      render();
    }

    // Renderização de células
    function renderCell(colDef, rowData, rowId) {
      const td = document.createElement("td");
      td.className = deriveCellClass(colDef);
      td.style.width = colDef.width || "130px";
      td.style.minWidth = td.style.width;
      td.style.maxWidth = td.style.width;
      const value = getCI(rowData, colDef.dataField);
      const alert = resolveAlertVisual(colDef, value);

      const wrapInAlert = (node, typeSafe) => wrapCellWithAlert(node, alert, { invasiveOnInputs: !!typeSafe });

      switch (colDef.columnType) {
        case "data_text": {
          const span = document.createElement("div");
          span.textContent = String(value ?? "");
          td.appendChild(wrapInAlert(span, true));
          break;
        }
        case "data_number": {
          const places = /(^id$)|(^id_)|(_id$)/i.test(colDef.columnName || colDef.dataField) ? 0 : 2;
          const span = document.createElement("div");
          span.textContent = formatNumberBRN(value, places);
          td.appendChild(wrapInAlert(span, true));
          break;
        }
        case "data_iconphoto": {
          const photoField = colDef.imageField?.trim() || null;
          const iconField = colDef.iconField?.trim() || null;
          const photo = photoField ? getCI(rowData, photoField) : null;
          const iconRaw = iconField ? getCI(rowData, iconField) : null;
          const icon = iconRaw ? getIconComponent(String(iconRaw)) : null;
          const iconColor = getCI(rowData, colDef.iconColorField || "corIcone") || undefined;
          const bg1 = getCI(rowData, colDef.iconBgColor1Field || "bg1") || "transparent";
          const bg2 = getCI(rowData, colDef.iconBgColor2Field || "bg2");
          const shape = colDef.imageShape === "rounded" ? "8px" : (colDef.imageShape === "square" ? "0px" : "9999px");
          const wrapper = document.createElement("div");
          wrapper.style.display = "flex";
          wrapper.style.justifyContent = "center";
          wrapper.style.alignItems = "center";
          wrapper.style.width = "100%";
          const box = document.createElement("div");
          box.className = "icon-circle";
          box.style.borderRadius = shape;
          if (photo) {
            const img = document.createElement("img");
            img.src = photo;
            img.alt = "avatar";
            img.className = "avatar-img";
            img.style.borderRadius = shape;
            img.onerror = () => {
              box.innerHTML = "";
              box.appendChild(renderFallbackIcon());
            };
            box.appendChild(img);
          } else if (icon) {
            box.style.background = bg2 ? `linear-gradient(135deg, ${bg1}, ${bg2})` : bg1;
            box.appendChild(renderLucideIcon(icon, iconColor || "#0f172a", 16));
          } else {
            box.appendChild(renderFallbackIcon());
          }
          wrapper.appendChild(box);
          td.appendChild(wrapInAlert(wrapper, true));
          break;
        }
        case "data_boolean_checkbox": {
          const checked = value === true || value === 1 || value === "1" || value === "true";
          const box = document.createElement("div");
          box.className = "checkbox" + (checked ? " checked" : "");
          box.innerHTML = checked ? renderCheckSVG() : "";
          // edição (mesma lógica de input)
          box.onclick = async () => {
            await handleCheckboxChange(colDef, rowData, !checked);
          };
          td.appendChild(wrapInAlert(box, true));
          break;
        }
        case "input_text":
        case "input_number": {
          const places = colDef.columnType === "input_number"
            ? (/^id$/i.test(colDef.columnName || colDef.dataField) ? 0 : 2)
            : undefined;
          const input = document.createElement("input");
          input.className = "input";
          input.type = "text";
          input.value = colDef.columnType === "input_number"
            ? formatNumberBRN(value, places)
            : String(value ?? "");
          input.onblur = async (e) => {
            let newVal = e.target.value;
            if (colDef.columnType === "input_number") {
              const parsed = parseNumberBR(newVal);
              newVal = isNaN(parsed) ? null : roundN(parsed, places);
            }
            if (String(newVal ?? "") === String(value ?? "")) return;
            await handleValueChange(colDef, rowData, newVal);
          };
          td.appendChild(wrapInAlert(input, false));
          break;
        }
        case "input_date": {
          const input = document.createElement("input");
          input.className = "input";
          input.type = "date";
          input.value = parseToYYYYMMDD(value, colDef.inputDateFormat);
          input.onchange = async (e) => {
            const newVal = e.target.value;
            if (newVal === parseToYYYYMMDD(value, colDef.inputDateFormat)) return;
            await handleValueChange(colDef, rowData, newVal);
          };
          td.appendChild(wrapInAlert(input, false));
          break;
        }
        case "input_dropdown": {
          const select = document.createElement("select");
          select.className = "select";
          const fieldKey = resolveKey(colDef.dataField);
          const options = STATE.dynamicOptionsMap[fieldKey] || colDef.dropdownOptions || [];
          options.forEach(opt => {
            const o = document.createElement("option");
            o.value = String(opt.value);
            o.textContent = String(opt.label);
            if (String(opt.value) === String(value ?? "")) o.selected = true;
            select.appendChild(o);
          });
          select.onchange = async (e) => {
            const newVal = e.target.value;
            if (String(newVal) === String(value ?? "")) return;
            await handleValueChange(colDef, rowData, newVal);
          };
          td.appendChild(wrapInAlert(select, false));
          break;
        }
        case "action_button": {
          const btn = document.createElement("button");
          btn.className = colDef.buttonVariant === "destructive" ? "btn btn-danger" : "btn btn-ghost";
          btn.textContent = colDef.buttonText || "Ação";
          const interaction = getCI(rowData, colDef.interactionColumn);
          btn.disabled = !interaction;
          btn.onclick = async () => {
            if (!interaction) return;
            await handleMitraAction(interaction, colDef.setRowIdVariableForButton, rowData, {
              modalW: colDef.mitraModalWidthForButton,
              modalH: colDef.mitraModalHeightForButton,
            });
          };
          td.appendChild(btn);
          break;
        }
        case "action_buttons_group": {
          const wrapper = document.createElement("div");
          wrapper.style.display = "flex";
          wrapper.style.gap = "6px";
          wrapper.style.justifyContent = "center";
          (colDef.buttonsGroupConfig?.buttons || []).forEach(btnCfg => {
            if (btnCfg.queryColumn && getCI(rowData, btnCfg.queryColumn) !== 1) return;
            const interaction = getCI(rowData, btnCfg.interactionColumn);
            const btn = document.createElement("button");
            btn.className = "btn btn-ghost";
            btn.style.width = "28px";
            btn.style.height = "28px";
            btn.style.padding = "0";
            btn.disabled = !interaction;
            btn.title = btnCfg.hoverText || "";
            if (btnCfg.bgColor) {
              btn.style.background = btnCfg.bgColor;
              btn.style.color = btnCfg.iconColor || "#fff";
              btn.style.border = "none";
            }
            btn.appendChild(renderLucideIcon(getIconComponent(btnCfg.icon), btnCfg.iconColor || "#0f172a", 16));
            btn.onclick = async () => {
              if (!interaction) return;
              await handleMitraAction(interaction, colDef.buttonsGroupConfig?.setRowIdVariable, rowData, {});
            };
            wrapper.appendChild(btn);
          });
          td.appendChild(wrapper);
          break;
        }
        default: {
          const span = document.createElement("div");
          span.textContent = String(value ?? "");
          td.appendChild(span);
        }
      }
      return td;
    }

    function renderFallbackIcon() {
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttribute("viewBox", "0 0 24 24");
      svg.setAttribute("width", "16");
      svg.setAttribute("height", "16");
      svg.innerHTML = '<path d="M21 15V5a2 2 0 0 0-2-2H5c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h9" stroke="#5D6585" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/><circle cx="9" cy="9" r="2" fill="#5D6585"/><path d="m3 20 6-6 2 2 5-5 4 4" stroke="#5D6585" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>';
      return svg;
    }
    function renderLucideIcon(name, color, size = 16) {
      const span = document.createElement("span");
      span.style.display = "inline-flex";
      span.style.width = `${size}px`;
      span.style.height = `${size}px`;
      span.innerHTML = lucidePaths(name, color, size);
      return span;
    }
    function renderCheckSVG() {
      return '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>';
    }

    // Paths mínimos de ícones (fallback simples)
    function lucidePaths(name, color = "#0f172a", size = 16) {
      const paths = {
        ArrowUp: '<path d="m5 11 7-7 7 7"/><path d="M12 18V4"/>',
        ArrowDown: '<path d="m19 13-7 7-7-7"/><path d="M12 5v14"/>',
        ArrowUpDown: '<path d="m21 16-4 4-4-4"/><path d="M17 20V4"/><path d="m3 8 4-4 4 4"/><path d="M7 4v16"/>',
        Eye: '<path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8Z"/><circle cx="12" cy="12" r="3"/>',
        EyeOff: '<path d="M9.88 9.88a3 3 0 1 0 4.24 4.24"/><path d="M10.73 5.08A10.44 10.44 0 0 1 12 5c7 0 11 7 11 7a17.05 17.05 0 0 1-3.07 4.45"/><path d="m1 1 22 22"/><path d="M6.61 6.61A17.05 17.05 0 0 0 1 12s4 7 11 7c1.64 0 3.16-.33 4.55-.92"/>',
        Trash2: '<path d="M3 6h18"/><path d="M8 6V4h8v2"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6"/><path d="M10 11v6"/><path d="M14 11v6"/>',
        Share: '<path d="M4 12v7a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-7"/><polyline points="16 6 12 2 8 6"/><line x1="12" x2="12" y1="2" y2="15"/>',
        X: '<path d="M18 6 6 18"/><path d="m6 6 12 12"/>',
        AlertTriangle: '<path d="M10.29 3.86 1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0Z"/><line x1="12" x2="12" y1="9" y2="13"/><line x1="12" x2="12.01" y1="17" y2="17"/>',
        AlertCircle: '<circle cx="12" cy="12" r="10"/><line x1="12" x2="12" y1="8" y2="12"/><line x1="12" x2="12.01" y1="16" y2="16"/>',
        FileText: '<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><path d="M14 2v6h6"/><path d="M16 13H8"/><path d="M16 17H8"/><path d="M10 9H8"/>',
        ImageOff: '<path d="m2 2 20 20"/><path d="M9.9 5H19a2 2 0 0 1 2 2v11.1"/><path d="M7.9 7.9 5 10a2 2 0 0 0-2 2v5a2 2 0 0 0 2 2h11"/><circle cx="9.9" cy="9.9" r="2.1"/><path d="m21 15-5-5a3 3 0 0 0-4.24 0L5 16"/>',
        HelpCircle: '<circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.82 1c0 2-3 3-3 3"/><path d="M12 17h.01"/>',
        Loader2: '<path d="M12 2v4"/><path d="m16.2 7.8 2.9-2.9"/><path d="M18 12h4"/><path d="m16.2 16.2 2.9 2.9"/><path d="M12 18v4"/><path d="m4.9 19.1 2.9-2.9"/><path d="M2 12h4"/><path d="m4.9 4.9 2.9 2.9"/>',
      };
      const inner = paths[name] || paths.HelpCircle;
      return `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" stroke="${color}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">${inner}</svg>`;
    }

    // Interações Mitra
    async function handleMitraAction(interaction, rowIdVar, rowData, opts) {
      const [type, idStr] = String(interaction).split(":");
      const id = Number(idStr);
      const rowId = getRowIdValue(rowData);
      if (rowIdVar && rowId !== undefined) {
        await setVariableMitra({ name: rowIdVar, content: rowId });
      }
      try {
        switch (type) {
          case "dbaction":
            await dbactionMitra({ id });
            await fetchData(true);
            updateComponentsMitra({ all: true });
            break;
          case "form":
            await waitIndefinitely(formMitra({ id, contentId: rowId }));
            await fetchData(true);
            updateComponentsMitra({ all: true });
            break;
          case "modal":
            safeModalMitra({
              id,
              width: opts.modalW || parseTamanhoModal.width,
              height: opts.modalH || parseTamanhoModal.height,
              floating: false,
              reload: MODAL_RELOAD_BEHAVIOR,
            });
            break;
          case "action":
            await actionMitra({ id });
            await fetchData(true);
            updateComponentsMitra({ all: true });
            break;
          default:
            console.warn("Interação desconhecida:", interaction);
        }
      } catch (err) {
        console.error("Erro ao executar interação:", err);
      }
    }

    async function handleValueChange(colDef, rowData, newValue) {
      const rowId = getRowIdValue(rowData);
      const varRowId = window.componentData?.setRowIdForChangeDBAction;
      const varValue = colDef.onValueChangeMitraVariable || window.componentData?.onValueChangeMitraVariable;
      if (varRowId && rowId !== undefined) {
        await setVariableMitra({ name: varRowId, content: rowId });
      }
      if (varValue) {
        await setVariableMitra({ name: varValue, content: newValue });
      }
      if (colDef.onValueChangeDBActionID !== undefined) {
        await dbactionMitra({ id: colDef.onValueChangeDBActionID });
        updateComponentsMitra({ all: true });
      }
      await fetchData(true);
    }

    async function handleCheckboxChange(colDef, rowData, newChecked) {
      const newValue = newChecked ? 1 : 0;
      await handleValueChange(colDef, rowData, newValue);
    }

    function getRowIdValue(row) {
      // tenta achar ID (case-insensitive) ou primeira coluna
      if (STATE.headerLUT["id"]) return row[STATE.headerLUT["id"]];
      const keys = Object.keys(row || {});
      return row[keys[0]];
    }

    // Virtual scroll
    function setupVirtualScroll() {
      const updateVisible = () => {
        const h = refs.scroll.clientHeight;
        VIRTUAL_SCROLL.visible = Math.ceil(h / VIRTUAL_SCROLL.rowHeight);
      };
      updateVisible();
      window.addEventListener("resize", () => {
        updateVisible();
        renderVisibleRows();
      });
      refs.scroll.addEventListener("scroll", () => {
        VIRTUAL_SCROLL.scrollTop = refs.scroll.scrollTop;
        if (VIRTUAL_SCROLL.rafId) cancelAnimationFrame(VIRTUAL_SCROLL.rafId);
        VIRTUAL_SCROLL.rafId = requestAnimationFrame(renderVisibleRows);
      });
    }

    function calculateVisibleRange() {
      const startIndex = Math.floor(VIRTUAL_SCROLL.scrollTop / VIRTUAL_SCROLL.rowHeight) - VIRTUAL_SCROLL.buffer;
      const endIndex = startIndex + VIRTUAL_SCROLL.visible + (VIRTUAL_SCROLL.buffer * 2);
      return [Math.max(0, startIndex), Math.min((STATE.filtered || []).length, endIndex)];
    }

    function renderVisibleRows() {
      const [start, end] = calculateVisibleRange();
      const body = refs.tableBody;
      body.innerHTML = "";
      if (!STATE.filtered || STATE.filtered.length === 0) {
        const tr = document.createElement("tr");
        const td = document.createElement("td");
        td.colSpan = STATE.baseColumns.length || 1;
        td.className = "empty-state";
        td.textContent = "Nenhum registro encontrado.";
        tr.appendChild(td);
        body.appendChild(tr);
        refs.spacerTop.style.height = "0px";
        refs.spacerBottom.style.height = "0px";
        return;
      }

      const hasPivot = !!STATE.config.xAxisFkColumn && !!STATE.config.xAxisRowKeyColumn;
      if (hasPivot) {
        renderPivotRows(start, end);
        return;
      }

      const frag = document.createDocumentFragment();
      for (let i = start; i < end; i++) {
        const row = STATE.filtered[i];
        const tr = document.createElement("tr");
        tr.className = "data-row";
        STATE.baseColumns.forEach(col => {
          tr.appendChild(renderCell(col, row, i));
        });
        frag.appendChild(tr);
      }
      body.appendChild(frag);
      refs.spacerTop.style.height = `${start * VIRTUAL_SCROLL.rowHeight}px`;
      refs.spacerBottom.style.height = `${(STATE.filtered.length - end) * VIRTUAL_SCROLL.rowHeight}px`;
    }

    function renderPivotRows(start, end) {
      const body = refs.tableBody;
      body.innerHTML = "";
      const fkKey = resolveKey(STATE.config.xAxisFkColumn);
      const rowKey = resolveKey(STATE.config.xAxisRowKeyColumn);
      const fixedKeys = STATE.config.xAxisFixedColumns.map(resolveKey).filter(Boolean);
      const detailKeys = (STATE.config.xAxisDetailColumns || []).map(resolveKey).filter(Boolean);
      const labelKey = STATE.config.xAxisLabelColumn ? resolveKey(STATE.config.xAxisLabelColumn) : fkKey;

      // constrói mapa pivot: rowKey => { fixedRow, byGroup }
      const pivot = new Map();
      for (const r of STATE.filtered) {
        const rk = r[rowKey];
        const fk = r[fkKey];
        const key = String(rk ?? "");
        if (!pivot.has(key)) pivot.set(key, { fixedRow: r, byGroup: new Map() });
        const slot = pivot.get(key);
        if (!slot.fixedRow) slot.fixedRow = r;
        slot.byGroup.set(fk, r);
      }
      const pivotRows = Array.from(pivot.entries());

      // Ordenação pivot
      const ss = STATE.sortState;
      if (ss.isPivot && ss.pivotGroupKey) {
        const chosen = ss.pivotDetailKey || detailKeys[0];
        const isNumber = (colId) => {
          const def = STATE.baseColumns.find(c => resolveKey(c.dataField) === colId);
          return def?.columnType === "data_number" || def?.columnType === "input_number";
        };
        const isDate = (colId) => {
          const def = STATE.baseColumns.find(c => resolveKey(c.dataField) === colId);
          return def?.columnType === "input_date" || /data|date/i.test(String(def?.columnName || def?.dataField || ""));
        };
        const toComp = (v, colId) => {
          if (v == null) return null;
          if (isNumber(colId)) {
            const n = typeof v === "number" ? v : parseNumberBR(String(v));
            return isNaN(n) ? null : n;
          }
          if (isDate(colId)) {
            const ts = Date.parse(v);
            return isNaN(ts) ? null : ts;
          }
          return String(v);
        };
        pivotRows.sort((a, b) => {
          const aRow = a[1].byGroup.get(ss.pivotGroupKey) || {};
          const bRow = b[1].byGroup.get(ss.pivotGroupKey) || {};
          const av = toComp(aRow[chosen], chosen);
          const bv = toComp(bRow[chosen], chosen);
          if (av === null && bv === null) return 0;
          if (av === null) return 1;
          if (bv === null) return -1;
          const cmp = av === bv ? 0 : (av > bv ? 1 : -1);
          return ss.dir === "asc" ? cmp : -cmp;
        });
      } else if (!ss.isPivot && ss.columnId) {
        const colId = ss.columnId;
        const isNumber = (colId) => {
          const def = STATE.baseColumns.find(c => resolveKey(c.dataField) === colId);
          return def?.columnType === "data_number" || def?.columnType === "input_number";
        };
        const isDate = (colId) => {
          const def = STATE.baseColumns.find(c => resolveKey(c.dataField) === colId);
          return def?.columnType === "input_date" || /data|date/i.test(String(def?.columnName || def?.dataField || ""));
        };
        const toComp = (v, colId) => {
          if (v == null) return null;
          if (isNumber(colId)) {
            const n = typeof v === "number" ? v : parseNumberBR(String(v));
            return isNaN(n) ? null : n;
          }
          if (isDate(colId)) {
            const ts = Date.parse(v);
            return isNaN(ts) ? null : ts;
          }
          return String(v);
        };
        pivotRows.sort((a, b) => {
          const av = toComp(a[1].fixedRow[colId], colId);
          const bv = toComp(b[1].fixedRow[colId], colId);
          if (av === null && bv === null) return 0;
          if (av === null) return 1;
          if (bv === null) return -1;
          const cmp = av === bv ? 0 : (av > bv ? 1 : -1);
          return ss.dir === "asc" ? cmp : -cmp;
        });
      }

      // recorte virtual
      const sliced = pivotRows.slice(start, end);
      const frag = document.createDocumentFragment();
      const detailKeysEffective = detailKeys.length ? detailKeys : STATE.baseColumns
        .filter(c => c.columnType !== "action_buttons_group" && !fixedKeys.includes(resolveKey(c.dataField)))
        .map(c => resolveKey(c.dataField));
      const groupOrder = Array.from(new Set(STATE.filtered.map(r => r[fkKey])));

      for (const [rkStr, pack] of sliced) {
        const tr = document.createElement("tr");
        tr.className = "data-row";
        if (fixedKeys.length) {
          fixedKeys.forEach(k => {
            const def = STATE.baseColumns.find(c => resolveKey(c.dataField) === k);
            tr.appendChild(renderCell(def || { dataField: k, columnType: "data_text", columnName: k }, pack.fixedRow, rkStr));
          });
        } else {
          const td = document.createElement("td");
          td.textContent = "";
          td.style.width = "80px";
          tr.appendChild(td);
        }

        groupOrder.forEach(gVal => {
          detailKeysEffective.forEach(dk => {
            const def = STATE.baseColumns.find(c => resolveKey(c.dataField) === dk);
            const rowForGroup = pack.byGroup.get(gVal) || {};
            tr.appendChild(renderCell(def || { dataField: dk, columnType: "data_text", columnName: dk }, rowForGroup, rkStr));
          });
        });
        frag.appendChild(tr);
      }
      body.appendChild(frag);
      refs.spacerTop.style.height = `${start * VIRTUAL_SCROLL.rowHeight}px`;
      refs.spacerBottom.style.height = `${(pivotRows.length - end) * VIRTUAL_SCROLL.rowHeight}px`;
    }

    // Totalizadores (tfoot)
    function renderTotals() {
      const foot = refs.tableFoot;
      foot.innerHTML = "";
      if (STATE.config.xAxisFkColumn || STATE.config.xAxisRowKeyColumn) return; // não soma em pivô
      const totals = STATE.queryTotals || {};
      if (Object.keys(totals).length === 0) return;
      const tr = document.createElement("tr");
      tr.className = "totalizer";
      const visibleCols = STATE.baseColumns;
      let firstTotalIndex = visibleCols.findIndex(col => totals[resolveKey(col.dataField)] !== undefined);
      if (firstTotalIndex === -1) firstTotalIndex = visibleCols.length;
      visibleCols.forEach((col, idx) => {
        if (idx === 0) {
          const td = document.createElement("td");
          td.colSpan = Math.max(firstTotalIndex, 1);
          td.textContent = "Totais";
          td.className = "cell-left";
          tr.appendChild(td);
        }
        if (idx < firstTotalIndex) return;
        const key = resolveKey(col.dataField);
        const td = document.createElement("td");
        td.className = deriveCellClass(col);
        if (totals[key] !== undefined) {
          const places = (/^id$/i.test(col.columnName || col.dataField)) ? 0 : 2;
          td.textContent = (totals[key] ?? null) !== null ? formatNumberBRN(totals[key], places) : "—";
        } else {
          td.textContent = "";
        }
        tr.appendChild(td);
      });
      foot.appendChild(tr);
    }

    function renderHeaderButtons() {
      const container = refs.headerButtons;
      container.innerHTML = "";
      STATE.headerButtons.forEach(btn => {
        const b = document.createElement("button");
        b.className = "btn btn-ghost";
        if (btn.bgColor) {
          b.style.background = btn.bgColor;
          b.style.color = btn.textColor || "#fff";
          b.style.border = "none";
        }
        if (btn.icon) {
          b.appendChild(renderLucideIcon(getIconComponent(btn.icon), btn.textColor || "#0f172a", 16));
        }
        const span = document.createElement("span");
        span.textContent = btn.label || "";
        b.appendChild(span);
        b.onclick = async () => {
          if (!btn.interaction) return;
          await handleMitraAction(btn.interaction, null, {}, { modalW: parseTamanhoModal.width, modalH: parseTamanhoModal.height });
        };
        container.appendChild(b);
      });
    }

    function setLoading(show) {
      STATE.loading = show;
      refs.loading.classList.toggle("show", show);
    }

    // Fetch principal
    async function fetchData(silent = false, syncSearchVar = false, searchValue = "") {
      if (!silent) setLoading(true);
      try {
        if (syncSearchVar && STATE.config.variableSearch) {
          await setVariableMitra({ name: STATE.config.variableSearch, content: STATE.config.enableSearch ? searchValue : "" });
        }
        const res = await queryMitra({ query: STATE.config.query, jdbcId: STATE.config.jdbcId });
        buildHeaderLUT(res.headers || []);
        STATE.data = transformMitraData(res);
        await fetchDropdownOptions();
        await fetchTotalizerData();
        await fetchHeaderButtons();
        applyFiltersAndSort();
        render();
      } catch (e) {
        console.error("Erro ao buscar dados:", e);
        STATE.data = [];
        STATE.filtered = [];
        render();
      } finally {
        if (!silent) setLoading(false);
      }
    }

    // Render geral
    function render() {
      renderHeader();
      renderVisibleRows();
      renderTotals();
      renderHeaderButtons();
    }

    // Busca (live)
    function setupSearch() {
      refs.searchInput.addEventListener("input", async (e) => {
        const val = e.target.value;
        STATE.searchTerm = val;
        applyFiltersAndSort();
        renderVisibleRows();
        if (!STATE.config.variableSearch) return;
        // live search para backend
        if (STATE.lastSentSearch !== val) {
          STATE.lastSentSearch = val;
          await fetchData(true, true, val);
        }
      });
      refs.searchInput.addEventListener("keydown", async (e) => {
        if (e.key === "Enter") {
          STATE.lastSentSearch = refs.searchInput.value;
          await fetchData(true, true, STATE.lastSentSearch);
        }
      });
    }

    // Init
    async function init() {
      parseComponentData();
      setupVirtualScroll();
      setupSearch();
      await fetchData(false, !!STATE.config.variableSearch, "");
      window.updateMitra = () => fetchData(true);
    }

    document.addEventListener("DOMContentLoaded", init);
  </script>
</body>
</html>

