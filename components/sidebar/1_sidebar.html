
<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sidebar Mitra</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Tooltip styles para estado colapsado */
    .tooltip {
      position: relative;
    }
    
    .tooltip-content {
      position: absolute;
      left: calc(100% + 8px);
      top: 50%;
      transform: translateY(-50%);
      background-color: #1e293b;
      color: white;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 12px;
      white-space: nowrap;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.2s, visibility 0.2s;
      z-index: 50;
      pointer-events: none;
    }
    
    .tooltip-content::before {
      content: '';
      position: absolute;
      right: 100%;
      top: 50%;
      transform: translateY(-50%);
      border: 6px solid transparent;
      border-right-color: #1e293b;
    }
    
    .tooltip:hover .tooltip-content {
      opacity: 1;
      visibility: visible;
    }
    
    /* Scrollbar customizada */
    .sidebar-scroll::-webkit-scrollbar {
      width: 6px;
    }
    
    .sidebar-scroll::-webkit-scrollbar-track {
      background: #f1f5f9;
    }
    
    .sidebar-scroll::-webkit-scrollbar-thumb {
      background: #cbd5e1;
      border-radius: 3px;
    }
    
    .sidebar-scroll::-webkit-scrollbar-thumb:hover {
      background: #94a3b8;
    }
  </style>
</head>
<body class="bg-slate-50">
  <div class="flex h-screen">
    <!-- Sidebar -->
    <aside 
      id="sidebar" 
      class="bg-white border-r border-slate-200 transition-all duration-300 ease-in-out flex flex-col w-72 shadow-sm"
    >
      <!-- Header com Logo e Botão Colapsar -->
      <div class="flex items-center justify-between p-5 border-b border-slate-200 bg-slate-50/60">
        <div id="logo-container" class="flex items-center space-x-2.5">
          <div id="logo-image-container" class="w-9 h-9 bg-blue-600 rounded-lg flex items-center justify-center shadow-sm overflow-hidden">
            <img id="logo-image" src="" alt="Logo" class="hidden w-full h-full object-contain" />
            <span id="logo-icon" class="text-white font-bold text-base">A</span>
          </div>
          <div id="logo-text" class="flex flex-col">
            <span id="logo-name" class="font-semibold text-slate-800 text-base">App</span>
            <span id="logo-subtitle" class="text-xs text-slate-500">Dashboard</span>
          </div>
        </div>
        
        <button
          id="btn-collapse"
          onclick="toggleSidebar()"
          class="p-1.5 rounded-md hover:bg-slate-100 transition-all duration-200"
          aria-label="Colapsar sidebar"
          title="Colapsar sidebar"
        >
          <svg id="icon-collapse" class="h-4 w-4 text-slate-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
          </svg>
        </button>
      </div>

      <!-- Campo de Busca -->
      <div id="search-container" class="px-4 py-3 border-b border-slate-200">
        <div class="relative">
          <svg class="absolute left-3 top-1/2 transform -translate-y-1/2 h-3.5 w-3.5 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
          </svg>
          <input
            id="search-input"
            type="text"
            placeholder="Buscar..."
            oninput="handleSearch(this.value)"
            class="w-full pl-9 pr-4 py-2 bg-slate-50 border border-slate-200 rounded-md text-sm placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-200"
          />
        </div>
      </div>

      <!-- Navegação -->
      <nav id="navigation" class="flex-1 px-3 py-2 overflow-y-auto sidebar-scroll">
        <ul id="menu-items" class="space-y-0.5">
          <!-- Itens do menu serão inseridos aqui via JavaScript -->
        </ul>
      </nav>

      <!-- Seção de Perfil -->
      <div class="mt-auto border-t border-slate-200">
        <div id="profile-container" class="border-b border-slate-200 bg-slate-50/30 p-3">
          <div id="profile-expanded" class="relative">
            <button id="profile-button" onclick="toggleUserMenu()" class="w-full flex items-center px-3 py-2 rounded-md bg-white hover:bg-slate-50 transition-colors duration-200">
              <div class="w-8 h-8 bg-slate-200 rounded-full flex items-center justify-center overflow-hidden flex-shrink-0">
                <img id="user-avatar" src="" alt="Avatar" class="hidden w-full h-full object-cover" />
                <span id="user-initials" class="text-slate-700 font-medium text-sm">JD</span>
              </div>
              <div class="flex-1 min-w-0 ml-2.5 text-left">
                <p id="user-name" class="text-sm font-medium text-slate-800 truncate">João Silva</p>
                <p id="user-email" class="text-xs text-slate-500 truncate">usuario@email.com</p>
              </div>
              <div class="w-2 h-2 bg-green-500 rounded-full ml-2 flex-shrink-0" title="Online" />
              <svg class="h-4 w-4 text-slate-400 ml-2 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
              </svg>
            </button>
            <!-- Dropdown do Menu do Usuário -->
            <div id="user-menu-dropdown" class="hidden absolute bottom-full left-0 right-0 mb-2 bg-white border border-slate-200 rounded-md shadow-lg z-50 overflow-hidden">
              <!-- Itens do menu serão inseridos aqui via JavaScript -->
            </div>
          </div>
          
          <div id="profile-collapsed" class="hidden flex justify-center">
            <div class="relative tooltip">
              <button id="profile-button-collapsed" onclick="toggleUserMenu()" class="w-9 h-9 bg-slate-200 rounded-full flex items-center justify-center overflow-hidden">
                <img id="user-avatar-collapsed" src="" alt="Avatar" class="hidden w-full h-full object-cover" />
                <span id="user-initials-collapsed" class="text-slate-700 font-medium text-sm">JD</span>
              </button>
              <div class="absolute -bottom-1 -right-1 w-3 h-3 bg-green-500 rounded-full border-2 border-white" />
              <div class="tooltip-content">
                <span id="tooltip-user-name">João Silva</span>
                <br>
                <span id="tooltip-user-email" class="text-xs opacity-75">usuario@email.com</span>
              </div>
            </div>
            <!-- Dropdown do Menu do Usuário (colapsado) -->
            <div id="user-menu-dropdown-collapsed" class="hidden absolute bottom-full left-0 mb-2 bg-white border border-slate-200 rounded-md shadow-lg z-50 min-w-[200px] overflow-hidden">
              <!-- Itens do menu serão inseridos aqui via JavaScript -->
            </div>
          </div>
        </div>

      </div>
    </aside>

    <!-- Conteúdo Principal -->
    <main id="main-content" class="flex-1 transition-all duration-300 ease-in-out ml-0 overflow-hidden">
      <div id="mitra-main-content" class="w-full h-full">
        <div id="mitra-initial-placeholder" class="flex flex-col items-center justify-center h-full text-slate-400">
          <svg class="w-12 h-12 mb-4 opacity-20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
          </svg>
          <p>Selecione um item no menu.</p>
        </div>
      </div>
    </main>
  </div>

  <!-- Botão FAB de Filtros -->
  <button
    id="filter-fab"
    onclick="toggleFilterModal()"
    class="fixed bottom-6 right-6 z-40 flex items-center justify-center w-14 h-14 bg-blue-600 text-white rounded-full shadow-lg hover:bg-blue-700 transition-all duration-200 hover:scale-110 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 hidden"
    aria-label="Abrir filtros"
    title="Filtros"
  >
    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z" />
    </svg>
    <span id="filter-badge" class="absolute -top-1 -right-1 flex items-center justify-center w-5 h-5 bg-red-500 text-white text-xs font-bold rounded-full hidden">0</span>
  </button>

  <!-- Backdrop do Modal -->
  <div
    id="filter-backdrop"
    onclick="closeFilterModal()"
    class="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 hidden transition-opacity duration-300"
  ></div>

  <!-- Modal Drawer de Filtros -->
  <div
    id="filter-drawer"
    class="fixed top-0 right-0 h-full w-full max-w-md bg-white shadow-2xl z-50 transform translate-x-full transition-transform duration-300 ease-in-out flex flex-col"
  >
    <!-- Header -->
    <div class="flex items-center justify-between p-4 border-b border-slate-200 bg-slate-50">
      <h2 id="filter-title" class="text-lg font-semibold text-slate-800">Filtros</h2>
      <button
        onclick="closeFilterModal()"
        class="p-2 rounded-md hover:bg-slate-200 transition-colors"
        aria-label="Fechar filtros"
      >
        <svg class="w-5 h-5 text-slate-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
        </svg>
      </button>
    </div>

    <!-- Corpo Scrollável -->
    <div id="filter-content" class="flex-1 overflow-y-auto p-4 space-y-4">
      <div id="filter-empty" class="flex flex-col items-center justify-center h-full text-slate-400">
        <svg class="w-12 h-12 mb-4 opacity-20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z" />
        </svg>
        <p>Nenhum filtro disponível para esta tela.</p>
      </div>
    </div>

    <!-- Footer -->
    <div class="flex items-center justify-between gap-2 p-4 border-t border-slate-200 bg-slate-50">
      <button
        onclick="clearFilters()"
        class="px-4 py-2 text-sm font-medium text-slate-700 bg-white border border-slate-300 rounded-md hover:bg-slate-50 transition-colors"
      >
        Limpar
      </button>
      <button
        onclick="applyFilters()"
        class="px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-md hover:bg-blue-700 transition-colors"
      >
        Aplicar Filtros
      </button>
    </div>
  </div>

  <script>
    // Estado da sidebar
    let isCollapsed = false;
    let activeItemId = null;
    let menuItems = [];
    let filteredItems = [];
    let userMenuItems = [];
    let userMenuOpen = false;
    let menuGroups = {}; // Agrupa itens por grupo
    
    // Estado de filtros
    let currentScreenId = null;
    let filtersByScreen = {};
    let filterValues = {}; // Armazena valores dos filtros por campo
    
    // Debounce para busca
    let searchTimeout = null;
    
    // Cache de elementos DOM frequentemente acessados
    const domCache = {
      get(id) {
        if (!this[id]) {
          this[id] = document.getElementById(id);
        }
        return this[id];
      },
      clear(id) {
        if (id) {
          delete this[id];
        } else {
          // Limpa todo o cache
          Object.keys(this).forEach(key => {
            if (key !== 'get' && key !== 'clear') {
              delete this[key];
            }
          });
        }
      }
    };

    /**
     * Extrai ID numérico de tela de URLs Mitra ou valores diretos
     * Suporta formato: "/embedded?inlineScreenId=123" ou apenas "123"
     */
    const resolveScreenId = (input) => {
      if (!input) return null;
      const str = String(input).trim();
      if (/^\d+$/.test(str)) return parseInt(str);
      const match = str.match(/[?&]inlineScreenId=(\d+)/);
      if (match && match[1]) return parseInt(match[1]);
      return null;
    };

    /**
     * Inicializa a sidebar com dados do componentData
     * Suporta tanto menuQuery (SQL) quanto menuItems (JSON)
     */
    async function initializeSidebar() {
      try {
        // Logo e nome da aplicação (suporta headerLogo, headerTitle, headerSubtitle)
        const logoUrl = componentData.headerLogo || componentData.logoImage;
        const logoTitle = componentData.headerTitle || componentData.logo;
        const logoSubtitle = componentData.headerSubtitle || componentData.logoSubtitle;
        
        if (logoUrl && logoUrl !== 'DEFAULTLOGO') {
          const logoImg = domCache.get('logo-image');
          logoImg.src = logoUrl;
          logoImg.classList.remove('hidden');
          domCache.get('logo-icon').classList.add('hidden');
        } else if (componentData.logoIcon) {
          domCache.get('logo-icon').textContent = componentData.logoIcon;
        }
        
        if (logoTitle) {
          domCache.get('logo-name').textContent = logoTitle;
        }
        if (logoSubtitle) {
          domCache.get('logo-subtitle').textContent = logoSubtitle;
        }

        // Carrega dados do usuário via userQuery ou userInfo
        await loadUserData();

        // Carrega itens do menu via menuQuery ou menuItems
        await loadMenuItems();

        // Carrega menu do usuário (userMenu)
        loadUserMenu();

        // Cor primária personalizada (se fornecida)
        if (componentData.primaryColor) {
          document.documentElement.style.setProperty('--primary-color', componentData.primaryColor);
        }

        // Estado inicial do item ativo (se fornecido)
        if (componentData.activeItemId) {
          activeItemId = componentData.activeItemId;
          updateActiveItem();
        }
      } catch (error) {
        console.error('Erro ao inicializar sidebar:', error);
      }
    }

    /**
     * Carrega dados do usuário via userQuery ou userInfo
     */
    async function loadUserData() {
      try {
        // Tenta carregar via userQuery (padrão do Menu nativo)
        if (componentData.userQuery) {
          const resultado = await queryMitra(componentData.userQuery);
          if (resultado && resultado.data && resultado.data.length > 0) {
            const userData = resultado.data[0]; // Primeira linha de dados
            const userNameCol = componentData.userName || 'NOME';
            const userEmailCol = componentData.userEmail || 'EMAIL';
            const userAvatarCol = componentData.userAvatar || 'FOTO_URL';
            
            // queryMitra retorna array de arrays
            // Assumindo ordem padrão: NOME, EMAIL, FOTO_URL
            // Ou mapeia pelos índices se a primeira linha for cabeçalho
            let name = '', email = '', avatar = '';
            
            if (Array.isArray(userData)) {
              // Se a primeira linha parece ser cabeçalho, pula ela
              const firstRow = resultado.data[0];
              const isHeader = firstRow.some(cell => typeof cell === 'string' && 
                (cell.toUpperCase() === userNameCol.toUpperCase() || 
                 cell.toUpperCase() === userEmailCol.toUpperCase()));
              
              const dataRow = isHeader && resultado.data.length > 1 ? resultado.data[1] : userData;
              
              // Tenta mapear pelos nomes das colunas se houver cabeçalho
              if (isHeader && Array.isArray(firstRow)) {
                const nameIdx = firstRow.findIndex(c => String(c).toUpperCase() === userNameCol.toUpperCase());
                const emailIdx = firstRow.findIndex(c => String(c).toUpperCase() === userEmailCol.toUpperCase());
                const avatarIdx = firstRow.findIndex(c => String(c).toUpperCase() === userAvatarCol.toUpperCase());
                
                if (nameIdx >= 0 && dataRow[nameIdx] !== undefined) name = String(dataRow[nameIdx] || '');
                if (emailIdx >= 0 && dataRow[emailIdx] !== undefined) email = String(dataRow[emailIdx] || '');
                if (avatarIdx >= 0 && dataRow[avatarIdx] !== undefined) avatar = String(dataRow[avatarIdx] || '');
              } else {
                // Ordem padrão: primeira coluna = nome, segunda = email, terceira = avatar
                name = String(dataRow[0] || '');
                email = String(dataRow[1] || '');
                avatar = String(dataRow[2] || '');
              }
            }
            
            updateUserDisplay(name, email, avatar);
            return;
          }
        }
        
        // Fallback para userInfo (JSON)
        if (componentData.userInfo) {
          const userInfo = JSON.parse(componentData.userInfo);
          updateUserDisplay(
            userInfo.name || '',
            userInfo.email || userInfo.role || '',
            userInfo.avatar || userInfo.photo || ''
          );
        }
      } catch (error) {
        console.error('Erro ao carregar dados do usuário:', error);
      }
    }

    /**
     * Atualiza exibição dos dados do usuário
     */
    function updateUserDisplay(name, email, avatar) {
      if (name) {
        domCache.get('user-name').textContent = name;
        domCache.get('tooltip-user-name').textContent = name;
        
        // Gera iniciais se não houver avatar
        if (!avatar && name) {
          const initials = name.split(' ').map(n => n[0]).join('').substring(0, 2).toUpperCase();
          domCache.get('user-initials').textContent = initials;
          domCache.get('user-initials-collapsed').textContent = initials;
        }
      }
      
      if (email) {
        domCache.get('user-email').textContent = email;
        domCache.get('tooltip-user-email').textContent = email;
      }
      
      if (avatar) {
        const avatarImg = domCache.get('user-avatar');
        const avatarImgCollapsed = domCache.get('user-avatar-collapsed');
        avatarImg.src = avatar;
        avatarImg.classList.remove('hidden');
        avatarImgCollapsed.src = avatar;
        avatarImgCollapsed.classList.remove('hidden');
        domCache.get('user-initials').classList.add('hidden');
        domCache.get('user-initials-collapsed').classList.add('hidden');
      }
    }

    /**
     * Carrega itens do menu via menuQuery (SQL) ou menuItems (JSON)
     */
    async function loadMenuItems() {
      try {
        // Prioridade: menuQuery (padrão do Menu nativo)
        if (componentData.menuQuery) {
          const resultado = await queryMitra(componentData.menuQuery);
          if (resultado && resultado.data) {
            menuItems = parseMenuQueryResult(resultado.data);
            filteredItems = [...menuItems];
            renderMenuItems();
            return;
          }
        }
        
        // Fallback para menuItems (JSON)
        if (componentData.menuItems) {
          menuItems = JSON.parse(componentData.menuItems);
          filteredItems = [...menuItems];
          renderMenuItems();
        }
      } catch (error) {
        console.error('Erro ao carregar itens do menu:', error);
      }
    }

    /**
     * Parse do resultado da query SQL do menu
     * Mapeia colunas conforme configuração do componentData
     * queryMitra retorna { data: [[valor1, valor2, ...], ...] } - array de arrays
     */
    function parseMenuQueryResult(data) {
      if (!data || data.length === 0) return [];
      
      // Obtém nomes das colunas do mapeamento (nomes das colunas na query SQL)
      const idCol = componentData.menuIdColumn || 'ID';
      const nameCol = componentData.menuNameColumn || 'NAME';
      const iconCol = componentData.menuIconColumn || 'ICON';
      const groupCol = componentData.menuGroupColumn || 'GRUPO';
      const parentIdCol = componentData.menuParentIdColumn || 'PARENTID';
      const urlCol = componentData.menuUrlColumn || 'MENUURL';
      
      // queryMitra retorna array de arrays, então precisamos mapear pelos índices
      // Assumindo ordem padrão: ID, NAME, ICON, GRUPO, PARENTID, MENUURL
      // Mas pode variar conforme a query, então tentamos mapear pelo nome da coluna
      const items = [];
      const itemsMap = {}; // Para construir hierarquia
      
      // Tenta detectar ordem das colunas pela primeira linha
      // Se a primeira linha contém cabeçalhos, usa-os; senão assume ordem padrão
      let columnOrder = {};
      let startIndex = 0;
      
      // Se a primeira linha parece ser cabeçalho (strings), usa-a
      if (data.length > 0 && Array.isArray(data[0])) {
        const firstRow = data[0];
        const isHeader = firstRow.some(cell => typeof cell === 'string' && cell.toUpperCase() === cell);
        
        if (isHeader) {
          // Primeira linha é cabeçalho, mapeia índices
          firstRow.forEach((colName, idx) => {
            const colUpper = String(colName).toUpperCase();
            if (colUpper === idCol.toUpperCase()) columnOrder.id = idx;
            if (colUpper === nameCol.toUpperCase()) columnOrder.name = idx;
            if (colUpper === iconCol.toUpperCase()) columnOrder.icon = idx;
            if (colUpper === groupCol.toUpperCase()) columnOrder.group = idx;
            if (colUpper === parentIdCol.toUpperCase()) columnOrder.parentId = idx;
            if (colUpper === urlCol.toUpperCase()) columnOrder.url = idx;
          });
          startIndex = 1; // Pula cabeçalho
        } else {
          // Assume ordem padrão: ID, NAME, ICON, GRUPO, PARENTID, MENUURL
          columnOrder = { id: 0, name: 1, icon: 2, group: 3, parentId: 4, url: 5 };
        }
      }
      
      // Processa cada linha de dados
      for (let i = startIndex; i < data.length; i++) {
        const row = data[i];
        if (!Array.isArray(row) || row.length === 0) continue;
        
        const item = {
          id: String(row[columnOrder.id] ?? row[0] ?? i),
          label: String(row[columnOrder.name] ?? row[1] ?? ''),
          icon: String(row[columnOrder.icon] ?? row[2] ?? 'home'),
          group: String(row[columnOrder.group] ?? row[3] ?? ''),
          parentId: String(row[columnOrder.parentId] ?? row[4] ?? ''),
          url: String(row[columnOrder.url] ?? row[5] ?? '')
        };
        
        // Converte ícone PascalCase para lowercase (ex: LayoutDashboard -> layoutdashboard)
        // Remove espaços e converte para lowercase
        item.icon = item.icon.replace(/([A-Z])/g, (match) => match.toLowerCase()).toLowerCase();
        
        // Processa URL se for do formato Mitra (embedded)
        if (item.url && item.url.includes('/embedded')) {
          item.navigationType = 'iframe';
        }
        
        itemsMap[item.id] = item;
        items.push(item);
      }
      
      // Constrói hierarquia de submenus
      const rootItems = [];
      items.forEach(item => {
        if (!item.parentId || item.parentId === '' || item.parentId === null || item.parentId === 'NULL') {
          rootItems.push(item);
        } else {
          const parent = itemsMap[item.parentId];
          if (parent) {
            if (!parent.submenu) parent.submenu = [];
            parent.submenu.push(item);
          } else {
            rootItems.push(item); // Se parent não encontrado, adiciona como root
          }
        }
      });
      
      return rootItems;
    }

    /**
     * Carrega menu do usuário (userMenu)
     */
    function loadUserMenu() {
      try {
        if (componentData.userMenu) {
          userMenuItems = JSON.parse(componentData.userMenu);
          renderUserMenu();
        }
      } catch (error) {
        console.error('Erro ao carregar menu do usuário:', error);
      }
    }

    /**
     * Renderiza menu dropdown do usuário
     */
    function renderUserMenu() {
      const dropdownExpanded = domCache.get('user-menu-dropdown');
      const dropdownCollapsed = domCache.get('user-menu-dropdown-collapsed');
      
      if (!userMenuItems || userMenuItems.length === 0) return;
      
      const menuHTML = userMenuItems.map(item => {
        const iconName = (item.icone || item.icon || 'User').toLowerCase();
        return `
          <button
            onclick="handleUserMenuAction('${item.tipoInteracao}', ${item.idInteracao})"
            class="w-full flex items-center space-x-2 px-4 py-2 text-left text-sm text-slate-700 hover:bg-slate-50 transition-colors ${
              item.nome === 'Sair' ? 'text-red-600 hover:bg-red-50' : ''
            }"
          >
            ${getIconSVG(iconName, false)}
            <span>${item.nome}</span>
          </button>
        `;
      }).join('');
      
      dropdownExpanded.innerHTML = menuHTML;
      dropdownCollapsed.innerHTML = menuHTML;
    }

    /**
     * Manipula ações do menu do usuário
     */
    async function handleUserMenuAction(tipoInteracao, idInteracao) {
      toggleUserMenu(); // Fecha o menu
      
      try {
        if (tipoInteracao === 'action') {
          actionMitra({ id: parseInt(idInteracao) });
        } else if (tipoInteracao === 'form') {
          // Abre formulário (pode precisar de implementação específica)
          console.log('Abrir formulário:', idInteracao);
        } else if (tipoInteracao === 'modal') {
          modalMitra({ id: parseInt(idInteracao), width: 80, height: 90 });
        }
      } catch (error) {
        console.error('Erro ao executar ação do menu do usuário:', error);
      }
    }

    /**
     * Alterna menu do usuário (abre/fecha dropdown)
     */
    function toggleUserMenu() {
      userMenuOpen = !userMenuOpen;
      const dropdownExpanded = domCache.get('user-menu-dropdown');
      const dropdownCollapsed = domCache.get('user-menu-dropdown-collapsed');
      
      if (isCollapsed) {
        dropdownCollapsed.classList.toggle('hidden', !userMenuOpen);
      } else {
        dropdownExpanded.classList.toggle('hidden', !userMenuOpen);
      }
    }

    // Fecha menu do usuário ao clicar fora
    document.addEventListener('click', (e) => {
      if (!e.target.closest('#profile-container')) {
        userMenuOpen = false;
        domCache.get('user-menu-dropdown').classList.add('hidden');
        domCache.get('user-menu-dropdown-collapsed').classList.add('hidden');
      }
    });

    /**
     * Renderiza os itens do menu
     * Suporta agrupamento por grupos
     */
    function renderMenuItems() {
      const menuContainer = domCache.get('menu-items');
      menuContainer.innerHTML = '';

      // Agrupa itens por grupo se menuGroupColumn estiver configurado
      if (componentData.menuGroupColumn) {
        menuGroups = {};
        filteredItems.forEach(item => {
          const group = item.group || 'Outros';
          if (!menuGroups[group]) menuGroups[group] = [];
          menuGroups[group].push(item);
        });
        
        // Renderiza grupos
        Object.keys(menuGroups).forEach(groupName => {
          if (groupName && groupName !== 'Outros') {
            const groupHeader = document.createElement('li');
            groupHeader.className = 'px-3 py-2 mt-2';
            groupHeader.innerHTML = `
              <span class="text-xs font-semibold text-slate-500 uppercase tracking-wider">${groupName}</span>
            `;
            menuContainer.appendChild(groupHeader);
          }
          
          menuGroups[groupName].forEach(item => {
            menuContainer.appendChild(createMenuItemElement(item));
          });
        });
      } else {
        // Renderiza sem agrupamento
        filteredItems.forEach(item => {
          menuContainer.appendChild(createMenuItemElement(item));
        });
      }
    }

    /**
     * Cria elemento HTML para um item do menu
     */
    function createMenuItemElement(item) {
      const li = document.createElement('li');
      const hasSubmenu = item.submenu && item.submenu.length > 0;
      const isActive = activeItemId === item.id;
      const isSubmenuOpen = item.submenuOpen || false;
      const itemLabel = item.label || item.name || '';
      const itemIcon = item.icon || 'home';
      const itemBadge = item.badge || '';

      li.innerHTML = `
          <div class="relative">
            <button
              onclick="handleMenuItemClick('${item.id}')"
              class="menu-item w-full flex items-center space-x-2.5 px-3 py-2.5 rounded-md text-left transition-all duration-200 group ${
                isActive ? 'bg-blue-50 text-blue-700' : 'text-slate-600 hover:bg-slate-50 hover:text-slate-900'
              } ${isCollapsed ? 'justify-center px-2' : ''}"
              data-item-id="${item.id}"
              title="${isCollapsed ? itemLabel : ''}"
            >
              <div class="flex items-center justify-center min-w-[24px]">
                ${getIconSVG(itemIcon, isActive)}
              </div>
              
              ${!isCollapsed ? `
                <div class="flex items-center justify-between w-full">
                  <span class="text-sm ${isActive ? 'font-medium' : 'font-normal'}">${itemLabel}</span>
                  ${itemBadge ? `
                    <span class="px-1.5 py-0.5 text-xs font-medium rounded-full ${
                      isActive ? 'bg-blue-100 text-blue-700' : 'bg-slate-100 text-slate-600'
                    }">
                      ${itemBadge}
                    </span>
                  ` : ''}
                  ${hasSubmenu ? `
                    <svg class="h-4 w-4 text-slate-400 transition-transform ${isSubmenuOpen ? 'rotate-90' : ''}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                    </svg>
                  ` : ''}
                </div>
              ` : ''}

              ${isCollapsed && itemBadge ? `
                <div class="absolute top-1 right-1 w-4 h-4 flex items-center justify-center rounded-full bg-blue-100 border border-white">
                  <span class="text-[10px] font-medium text-blue-700">
                    ${parseInt(itemBadge) > 9 ? '9+' : itemBadge}
                  </span>
                </div>
              ` : ''}

              ${isCollapsed ? `
                <div class="tooltip-content">
                  ${itemLabel}
                  ${itemBadge ? `<span class="ml-1.5 px-1 py-0.5 bg-slate-700 rounded-full text-[10px]">${itemBadge}</span>` : ''}
                </div>
              ` : ''}
            </button>
          </div>
          ${hasSubmenu && !isCollapsed ? `
            <div id="submenu-${item.id}" class="ml-4 mt-1 ${isSubmenuOpen ? '' : 'hidden'}">
              ${renderSubmenu(item.submenu, item.id)}
            </div>
          ` : ''}
      `;

      return li;
    }

    /**
     * Renderiza submenu
     */
    function renderSubmenu(submenuItems, parentId) {
      return submenuItems.map(subItem => {
        const isActive = activeItemId === subItem.id;
        return `
          <button
            onclick="handleMenuItemClick('${subItem.id}', '${parentId}')"
            class="w-full flex items-center space-x-2 px-3 py-2 rounded-md text-left transition-all duration-200 text-sm ${
              isActive ? 'bg-blue-50 text-blue-700 font-medium' : 'text-slate-600 hover:bg-slate-50'
            }"
            data-item-id="${subItem.id}"
          >
            <div class="w-1.5 h-1.5 rounded-full bg-slate-400 ${isActive ? 'bg-blue-600' : ''}"></div>
            <span>${subItem.label}</span>
            ${subItem.badge ? `
              <span class="ml-auto px-1.5 py-0.5 text-xs font-medium rounded-full bg-slate-100 text-slate-600">
                ${subItem.badge}
              </span>
            ` : ''}
          </button>
        `;
      }).join('');
    }

    /**
     * Definição de ícones SVG (Lucide)
     * Organizado em objeto separado para facilitar manutenção
     */
    const iconDefinitions = {
      home: (iconClass) => `<svg class="${iconClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" />
      </svg>`,
      dashboard: (iconClass) => `<svg class="${iconClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
      </svg>`,
      user: (iconClass) => `<svg class="${iconClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
      </svg>`,
      settings: (iconClass) => `<svg class="${iconClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
      </svg>`,
      bell: (iconClass) => `<svg class="${iconClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9" />
      </svg>`,
      file: (iconClass) => `<svg class="${iconClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
      </svg>`,
      chart: (iconClass) => `<svg class="${iconClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
      </svg>`,
      logout: (iconClass) => `<svg class="${iconClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" />
      </svg>`,
      layoutdashboard: (iconClass) => `<svg class="${iconClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
      </svg>`,
      users: (iconClass) => `<svg class="${iconClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197M13 7a4 4 0 11-8 0 4 4 0 018 0z" />
      </svg>`,
      piechart: (iconClass) => `<svg class="${iconClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 3.055A9.001 9.001 0 1020.945 13H11V3.055z" />
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.488 9H15V3.512A9.025 9.025 0 0120.488 9z" />
      </svg>`
    };

    /**
     * Retorna SVG do ícone baseado no nome
     * Suporta ícones em PascalCase (Lucide) convertendo para lowercase
     */
    function getIconSVG(iconName, isActive = false) {
      const iconClass = `h-4.5 w-4.5 flex-shrink-0 ${isActive ? 'text-blue-600' : 'text-slate-500 group-hover:text-slate-700'}`;
      
      // Converte PascalCase para lowercase (ex: LayoutDashboard -> layoutdashboard)
      // Remove espaços e converte tudo para lowercase
      const normalizedName = String(iconName || 'home')
        .replace(/([A-Z])/g, (match) => match.toLowerCase())
        .toLowerCase()
        .replace(/\s+/g, '');
      
      const iconFn = iconDefinitions[normalizedName];
      return iconFn ? iconFn(iconClass) : iconDefinitions.home(iconClass);
    }

    /**
     * Alterna estado colapsado/expandido da sidebar
     */
    function toggleSidebar() {
      isCollapsed = !isCollapsed;
      const sidebar = domCache.get('sidebar');
      const logoText = domCache.get('logo-text');
      const searchContainer = domCache.get('search-container');
      const profileExpanded = domCache.get('profile-expanded');
      const profileCollapsed = domCache.get('profile-collapsed');
      const iconCollapse = domCache.get('icon-collapse');
      const mainContent = domCache.get('main-content');

      if (isCollapsed) {
        sidebar.classList.remove('w-72');
        sidebar.classList.add('w-20');
        logoText.classList.add('hidden');
        searchContainer.classList.add('hidden');
        profileExpanded.classList.add('hidden');
        profileCollapsed.classList.remove('hidden');
        iconCollapse.classList.add('rotate-180');
        mainContent.classList.remove('ml-0');
        mainContent.classList.add('ml-20');
        
        // Adiciona tooltips aos itens do menu
        document.querySelectorAll('.menu-item').forEach(item => {
          item.classList.add('tooltip');
        });
      } else {
        sidebar.classList.remove('w-20');
        sidebar.classList.add('w-72');
        logoText.classList.remove('hidden');
        searchContainer.classList.remove('hidden');
        profileExpanded.classList.remove('hidden');
        profileCollapsed.classList.add('hidden');
        iconCollapse.classList.remove('rotate-180');
        mainContent.classList.remove('ml-20');
        mainContent.classList.add('ml-0');
        
        // Remove tooltips dos itens do menu
        document.querySelectorAll('.menu-item').forEach(item => {
          item.classList.remove('tooltip');
        });
      }

      renderMenuItems();
    }

    /**
     * Manipula clique em item do menu
     */
    async function handleMenuItemClick(itemId, parentId = null) {
      const item = findMenuItem(itemId, menuItems);
      
      if (!item) {
        console.error(`Item de menu não encontrado: ${itemId}`);
        return;
      }

      // Se tem submenu, apenas expande/recolhe
      if (item.submenu && item.submenu.length > 0 && !parentId) {
        toggleSubmenu(itemId);
        return;
      }

      // Define item ativo
      activeItemId = itemId;
      updateActiveItem();

      // Navega usando funções Mitra
      await handleNavigation(item);
    }

    /**
     * Encontra item do menu recursivamente
     */
    function findMenuItem(itemId, items) {
      for (const item of items) {
        if (item.id == itemId) {
          return item;
        }
        if (item.submenu) {
          const found = findMenuItem(itemId, item.submenu);
          if (found) return found;
        }
      }
      return null;
    }

    /**
     * Alterna submenu expandido/recolhido
     */
    function toggleSubmenu(itemId) {
      const item = findMenuItem(itemId, menuItems);
      if (item && item.submenu) {
        item.submenuOpen = !item.submenuOpen;
        renderMenuItems();
      }
    }

    /**
     * Atualiza visual do item ativo
     */
    function updateActiveItem() {
      renderMenuItems();
    }

    /**
     * Manipula busca/filtro de itens
     * Com debounce para melhorar performance
     */
    function handleSearch(term) {
      // Limpa timeout anterior
      if (searchTimeout) {
        clearTimeout(searchTimeout);
      }
      
      // Aplica debounce de 300ms
      searchTimeout = setTimeout(() => {
        const searchTerm = term.toLowerCase().trim();
        
        if (!searchTerm) {
          filteredItems = [...menuItems];
        } else {
          filteredItems = menuItems.filter(item => {
            const matchesLabel = item.label.toLowerCase().includes(searchTerm);
            const matchesSubmenu = item.submenu && item.submenu.some(subItem => 
              subItem.label.toLowerCase().includes(searchTerm)
            );
            return matchesLabel || matchesSubmenu;
          });
        }
        
        renderMenuItems();
      }, 300);
    }

    /**
     * Navega usando funções nativas do Mitra
     * Carrega telas Mitra em iframe interno usando modalMitra com parâmetro parent
     * Compatível com formato do Menu nativo (URLs embedded)
     */
    async function handleNavigation(item) {
      try {
        // Define variável de contexto se necessário
        if (item.contextVariable) {
          await setVariableMitra({ 
            name: item.contextVariable, 
            content: item.contextValue || item.id 
          });
        }

        // Extrai screenId da URL ou do campo screenId
        const screenId = resolveScreenId(item.url) || resolveScreenId(item.screenId);

        if (screenId) {
          // Atualiza tela atual para sistema de filtros
          currentScreenId = screenId;
          updateFilterFabVisibility();
          
          // Recarrega a tela usando função centralizada
          await reloadCurrentScreen();
          return;
        }

        // Fallback: actionId (navegação via Action)
        if (item.actionId) {
          const actionId = parseInt(item.actionId);
          actionMitra({ id: actionId });
          return;
        }

        // Fallback: query (para casos especiais)
        if (item.query) {
          const resultado = await queryMitra(item.query);
          if (item.onQueryResult && typeof window[item.onQueryResult] === 'function') {
            window[item.onQueryResult](resultado);
          }
        }
      } catch (error) {
        console.error(`Erro ao navegar para ${item.label || item.name}:`, error);
      }
    }

    /**
     * Recarrega a tela atual (hard reset do container)
     * Centraliza a lógica de recarregamento para evitar duplicação
     */
    async function reloadCurrentScreen() {
      if (!currentScreenId) return;
      
      const mainWrapper = domCache.get('main-content');
      const oldContainer = domCache.get('mitra-main-content');
      if (oldContainer) oldContainer.remove();
      
      const newContainer = document.createElement('div');
      newContainer.id = 'mitra-main-content';
      newContainer.className = 'w-full h-full';
      mainWrapper.appendChild(newContainer);
      
      try {
        await modalMitra({ id: currentScreenId, parent: 'mitra-main-content', width: 100, height: 100 });
      } catch (e) {
        console.error("Erro ao recarregar tela Mitra:", e);
        newContainer.innerHTML = `<div class="flex h-full items-center justify-center text-red-500">Erro ao carregar</div>`;
      }
    }

    /**
     * Manipula logout (mantido para compatibilidade)
     * O logout agora é gerenciado via userMenu
     */
    async function handleLogout() {
      // Busca ação de logout no userMenu
      const logoutAction = userMenuItems.find(item => 
        item.nome === 'Sair' || item.nome === 'Logout'
      );
      
      if (logoutAction) {
        await handleUserMenuAction(logoutAction.tipoInteracao, logoutAction.idInteracao);
        return;
      }
      
      // Fallback para actionLogoutId (compatibilidade)
      if (componentData.actionLogoutId) {
        const actionId = parseInt(componentData.actionLogoutId);
        actionMitra({ id: actionId });
      } else {
        console.error('Ação de logout não configurada. Configure userMenu com ação "Sair" ou actionLogoutId.');
      }
    }

    /**
     * Sistema de Filtros por Tela
     */

    /**
     * Carrega configuração de filtros do componentData
     * Suporta dois formatos:
     * 1. Array de objetos: [{"id": "10", "title": "...", "fields": [...]}]
     * 2. Objeto com IDs como chaves: {"10": {"title": "...", "fields": [...]}} (compatibilidade)
     */
    function loadFilterConfig() {
      try {
        if (componentData.filtersByScreen) {
          const parsed = JSON.parse(componentData.filtersByScreen);
          
          // Se for array, converte para objeto indexado por ID
          if (Array.isArray(parsed)) {
            filtersByScreen = {};
            parsed.forEach(config => {
              if (config.id) {
                filtersByScreen[config.id] = {
                  title: config.title,
                  fields: config.fields || []
                };
              }
            });
          } else {
            // Formato antigo (objeto com IDs como chaves) - mantém compatibilidade
            filtersByScreen = parsed;
          }
        }
      } catch (error) {
        console.error('Erro ao carregar configuração de filtros:', error);
        filtersByScreen = {};
      }
    }

    /**
     * Obtém configuração de filtros para a tela atual
     * @returns {Object|null} Configuração de filtros ou null
     */
    function getFilterConfig() {
      return currentScreenId ? filtersByScreen[currentScreenId] : null;
    }

    /**
     * Atualiza visibilidade do FAB baseado na tela atual
     */
    function updateFilterFabVisibility() {
      const fab = domCache.get('filter-fab');
      if (!fab) return;
      
      if (getFilterConfig()) {
        fab.classList.remove('hidden');
        updateFilterBadge();
      } else {
        fab.classList.add('hidden');
      }
    }

    /**
     * Abre o modal de filtros
     */
    function toggleFilterModal() {
      const drawer = domCache.get('filter-drawer');
      const backdrop = domCache.get('filter-backdrop');
      
      if (drawer.classList.contains('translate-x-full')) {
        // Abre
        drawer.classList.remove('translate-x-full');
        backdrop.classList.remove('hidden');
        loadFilterFields();
        loadFilterValues();
      } else {
        // Fecha
        closeFilterModal();
      }
    }

    /**
     * Fecha o modal de filtros
     */
    function closeFilterModal() {
      const drawer = domCache.get('filter-drawer');
      const backdrop = domCache.get('filter-backdrop');
      
      drawer.classList.add('translate-x-full');
      backdrop.classList.add('hidden');
    }

    /**
     * Carrega e renderiza campos de filtro para a tela atual
     */
    function loadFilterFields() {
      const content = domCache.get('filter-content');
      const empty = domCache.get('filter-empty');
      const title = domCache.get('filter-title');
      
      if (!currentScreenId || !filtersByScreen[currentScreenId]) {
        content.innerHTML = '';
        empty.classList.remove('hidden');
        title.textContent = 'Filtros';
        return;
      }

      empty.classList.add('hidden');
      const config = filtersByScreen[currentScreenId];
      title.textContent = config.title || 'Filtros';
      
      let html = '';
      
      config.fields.forEach(field => {
        switch (field.type) {
          case 'text':
            html += renderTextField(field);
            break;
          case 'select':
            html += renderSelectField(field);
            break;
          case 'checkbox':
            html += renderCheckboxField(field);
            break;
          case 'dateRange':
            html += renderDateRangeField(field);
            break;
        }
      });
      
      content.innerHTML = html;
    }

    /**
     * Renderiza campo de texto
     */
    function renderTextField(field) {
      const value = filterValues[field.id] || '';
      return `
        <div class="space-y-2">
          <label class="block text-sm font-medium text-slate-700">${field.label}</label>
          <input
            type="text"
            id="filter-${field.id}"
            data-field-type="text"
            data-variable="${field.variable}"
            placeholder="${field.placeholder || ''}"
            value="${value}"
            class="w-full px-3 py-2 border border-slate-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
          />
        </div>
      `;
    }

    /**
     * Renderiza campo select
     */
    function renderSelectField(field) {
      const value = filterValues[field.id] || '';
      let optionsHtml = '';
      
      if (field.options) {
        optionsHtml = field.options.map(opt => 
          `<option value="${opt.value}" ${opt.value === value ? 'selected' : ''}>${opt.label}</option>`
        ).join('');
      }
      
      return `
        <div class="space-y-2">
          <label class="block text-sm font-medium text-slate-700">${field.label}</label>
          <select
            id="filter-${field.id}"
            data-field-type="select"
            data-variable="${field.variable}"
            class="w-full px-3 py-2 border border-slate-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
          >
            ${optionsHtml}
          </select>
        </div>
      `;
    }

    /**
     * Renderiza campo checkbox (múltipla seleção)
     */
    function renderCheckboxField(field) {
      const values = (filterValues[field.id] || '').split(',').filter(v => v);
      
      let checkboxesHtml = '';
      if (field.options) {
        checkboxesHtml = field.options.map(opt => {
          const checked = values.includes(opt.value);
          return `
            <label class="flex items-center space-x-2 cursor-pointer">
              <input
                type="checkbox"
                value="${opt.value}"
                data-field-id="${field.id}"
                data-variable="${field.variable}"
                ${checked ? 'checked' : ''}
                class="w-4 h-4 text-blue-600 border-slate-300 rounded focus:ring-blue-500"
              />
              <span class="text-sm text-slate-700">${opt.label}</span>
            </label>
          `;
        }).join('');
      }
      
      return `
        <div class="space-y-2">
          <label class="block text-sm font-medium text-slate-700">${field.label}</label>
          <div class="space-y-2" data-field-type="checkbox" data-field-id="${field.id}" data-variable="${field.variable}">
            ${checkboxesHtml}
          </div>
        </div>
      `;
    }

    /**
     * Renderiza campo de período (date range)
     */
    function renderDateRangeField(field) {
      const startValue = filterValues[`${field.id}_start`] || '';
      const endValue = filterValues[`${field.id}_end`] || '';
      
      return `
        <div class="space-y-2">
          <label class="block text-sm font-medium text-slate-700">${field.label}</label>
          <div class="grid grid-cols-2 gap-2">
            <div>
              <label class="block text-xs text-slate-500 mb-1">Início</label>
              <input
                type="date"
                id="filter-${field.id}_start"
                data-field-type="dateRange"
                data-variable-start="${field.variableStart}"
                value="${startValue}"
                class="w-full px-3 py-2 border border-slate-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              />
            </div>
            <div>
              <label class="block text-xs text-slate-500 mb-1">Fim</label>
              <input
                type="date"
                id="filter-${field.id}_end"
                data-field-type="dateRange"
                data-variable-end="${field.variableEnd}"
                value="${endValue}"
                class="w-full px-3 py-2 border border-slate-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              />
            </div>
          </div>
        </div>
      `;
    }

    /**
     * Coleta valores dos campos de filtro do DOM
     * @returns {Array} Array de objetos {name, content} para setVariableMitra
     */
    function collectFilterValues() {
      const config = getFilterConfig();
      if (!config) return [];
      
      const variablesToSet = [];
      
      config.fields.forEach(field => {
        switch (field.type) {
          case 'text':
            const textInput = document.getElementById(`filter-${field.id}`);
            if (textInput) {
              const value = textInput.value.trim();
              filterValues[field.id] = value;
              if (value) {
                variablesToSet.push({ name: field.variable, content: value });
              }
            }
            break;
            
          case 'select':
            const selectInput = document.getElementById(`filter-${field.id}`);
            if (selectInput) {
              const value = selectInput.value;
              filterValues[field.id] = value;
              if (value) {
                variablesToSet.push({ name: field.variable, content: value });
              }
            }
            break;
            
          case 'checkbox':
            const checkboxes = document.querySelectorAll(`input[type="checkbox"][data-field-id="${field.id}"]:checked`);
            const checkedValues = Array.from(checkboxes).map(cb => cb.value).filter(v => v);
            const checkboxValue = checkedValues.join(',');
            filterValues[field.id] = checkboxValue;
            if (checkboxValue) {
              variablesToSet.push({ name: field.variable, content: checkboxValue });
            }
            break;
            
          case 'dateRange':
            const startInput = document.getElementById(`filter-${field.id}_start`);
            const endInput = document.getElementById(`filter-${field.id}_end`);
            if (startInput && endInput) {
              const startValue = startInput.value;
              const endValue = endInput.value;
              filterValues[`${field.id}_start`] = startValue;
              filterValues[`${field.id}_end`] = endValue;
              if (startValue) {
                variablesToSet.push({ name: field.variableStart, content: startValue });
              }
              if (endValue) {
                variablesToSet.push({ name: field.variableEnd, content: endValue });
              }
            }
            break;
        }
      });
      
      return variablesToSet;
    }

    /**
     * Define variáveis Mitra a partir de um array de variáveis
     * @param {Array} variables Array de objetos {name, content}
     */
    async function setFilterVariables(variables) {
      for (const variable of variables) {
        await setVariableMitra(variable);
      }
    }

    /**
     * Carrega valores salvos das variáveis Mitra
     */
    async function loadFilterValues() {
      const config = getFilterConfig();
      if (!config) return;
      
      // Carrega valores das variáveis Mitra (seria necessário uma função queryMitra para variáveis)
      // Por enquanto, mantém valores em memória
      // TODO: Implementar carregamento de variáveis Mitra se necessário
    }

    /**
     * Aplica filtros e define variáveis Mitra
     */
    async function applyFilters() {
      const config = getFilterConfig();
      if (!config) return;
      
      try {
        // Coleta valores dos campos
        const variablesToSet = collectFilterValues();
        
        // Define todas as variáveis Mitra
        await setFilterVariables(variablesToSet);
        
        // Recarrega a tela atual
        await reloadCurrentScreen();
        
        updateFilterBadge();
        closeFilterModal();
      } catch (error) {
        console.error('Erro ao aplicar filtros:', error);
      }
    }

    /**
     * Coleta todas as variáveis para limpar (retorna array vazio para cada variável)
     * @returns {Array} Array de objetos {name, content: ''} para limpar variáveis
     */
    function collectFilterVariablesToClear() {
      const config = getFilterConfig();
      if (!config) return [];
      
      const variablesToClear = [];
      
      config.fields.forEach(field => {
        switch (field.type) {
          case 'text':
          case 'select':
            variablesToClear.push({ name: field.variable, content: '' });
            filterValues[field.id] = '';
            break;
          case 'checkbox':
            variablesToClear.push({ name: field.variable, content: '' });
            filterValues[field.id] = '';
            break;
          case 'dateRange':
            variablesToClear.push({ name: field.variableStart, content: '' });
            variablesToClear.push({ name: field.variableEnd, content: '' });
            filterValues[`${field.id}_start`] = '';
            filterValues[`${field.id}_end`] = '';
            break;
        }
      });
      
      return variablesToClear;
    }

    /**
     * Limpa todos os filtros
     */
    async function clearFilters() {
      const config = getFilterConfig();
      if (!config) return;
      
      try {
        // Coleta todas as variáveis para limpar
        const variablesToClear = collectFilterVariablesToClear();
        
        // Limpa variáveis Mitra
        await setFilterVariables(variablesToClear);
        
        // Recarrega campos
        loadFilterFields();
        updateFilterBadge();
        
        // Recarrega a tela atual
        await reloadCurrentScreen();
      } catch (error) {
        console.error('Erro ao limpar filtros:', error);
      }
    }

    /**
     * Atualiza badge com quantidade de filtros ativos
     */
    function updateFilterBadge() {
      const badge = domCache.get('filter-badge');
      if (!badge) return;
      
      let activeCount = 0;
      const config = getFilterConfig();
      
      if (config) {
        config.fields.forEach(field => {
          switch (field.type) {
            case 'text':
            case 'select':
              if (filterValues[field.id]) activeCount++;
              break;
            case 'checkbox':
              if (filterValues[field.id]) activeCount++;
              break;
            case 'dateRange':
              if (filterValues[`${field.id}_start`] || filterValues[`${field.id}_end`]) activeCount++;
              break;
          }
        });
      }
      
      if (activeCount > 0) {
        badge.textContent = activeCount;
        badge.classList.remove('hidden');
      } else {
        badge.classList.add('hidden');
      }
    }

    // Inicializa quando o DOM estiver pronto
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        initializeSidebar();
        loadFilterConfig();
      });
    } else {
      initializeSidebar();
      loadFilterConfig();
    }
  </script>
</body>
</html>
