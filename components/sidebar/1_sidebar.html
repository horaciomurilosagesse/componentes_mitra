
<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sidebar Mitra</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Variáveis CSS estilo shadcn */
    :root {
      --background: 0 0% 100%;
      --foreground: 222.2 84% 4.9%;
      --muted: 210 40% 96.1%;
      --muted-foreground: 215.4 16.3% 46.9%;
      --accent: 210 40% 96.1%;
      --accent-foreground: 222.2 47.4% 11.2%;
      --primary: 221.2 83.2% 53.3%;
      --primary-foreground: 210 40% 98%;
      --border: 214.3 31.8% 91.4%;
      --ring: 221.2 83.2% 53.3%;
    }

    /* Tooltip styles para estado colapsado - estilo shadcn */
    .tooltip {
      position: relative;
    }
    
    .tooltip-content {
      position: absolute;
      left: calc(100% + 8px);
      top: 50%;
      transform: translateY(-50%);
      background-color: hsl(222.2 84% 4.9%);
      color: hsl(210 40% 98%);
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 12px;
      white-space: nowrap;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out;
      z-index: 50;
      pointer-events: none;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }
    
    .tooltip-content::before {
      content: '';
      position: absolute;
      right: 100%;
      top: 50%;
      transform: translateY(-50%);
      border: 5px solid transparent;
      border-right-color: hsl(222.2 84% 4.9%);
    }
    
    .tooltip:hover .tooltip-content {
      opacity: 1;
      visibility: visible;
    }
    
    /* Scrollbar customizada - mais discreta estilo shadcn */
    .sidebar-scroll::-webkit-scrollbar {
      width: 6px;
    }
    
    .sidebar-scroll::-webkit-scrollbar-track {
      background: hsl(210 40% 98%);
    }
    
    .sidebar-scroll::-webkit-scrollbar-thumb {
      background: hsl(214.3 31.8% 85%);
      border-radius: 3px;
    }
    
    .sidebar-scroll::-webkit-scrollbar-thumb:hover {
      background: hsl(214.3 31.8% 75%);
    }
    
    /* Scrollbar oculta mas scroll funcional (modo colapsado) */
    .sidebar-scroll-hidden {
      overflow-y: auto;
      scrollbar-width: none; /* Firefox */
      -ms-overflow-style: none; /* IE e Edge */
    }
    
    .sidebar-scroll-hidden::-webkit-scrollbar {
      display: none; /* Chrome, Safari, Opera */
    }
    
    /* Otimizações para evitar recarregamento do iframe durante transição */
    #main-content {
      contain: layout style;
      /* Usa GPU acceleration para transições mais suaves */
      transform: translateZ(0);
      backface-visibility: hidden;
    }
    
    #mitra-main-content {
      contain: layout;
      isolation: isolate;
      /* Garante que o iframe não seja afetado por mudanças de layout */
      position: relative;
    }
    
    #mitra-main-content iframe {
      pointer-events: auto;
      /* Previne recarregamento durante resize */
      width: 100%;
      height: 100%;
      border: none;
    }
    
    /* Durante a transição, previne interações que podem causar recarregamento */
    #main-content.transitioning {
      pointer-events: none;
    }
    
    #main-content.transitioning #mitra-main-content {
      pointer-events: none;
    }
    
    /* Otimização adicional: usa transform para evitar reflow */
    #main-content.transitioning #mitra-main-content iframe {
      will-change: auto;
    }
    
    /* Estilos para Multiselect */
    .multiselect-container {
      position: relative;
    }
    
    .multiselect-trigger {
      position: relative;
      display: flex;
      align-items: center;
      width: 100%;
      min-height: 38px;
      padding: 8px 12px;
      background-color: white;
      border: 1px solid hsl(214.3 31.8% 91.4%);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s ease-in-out;
    }
    
    .multiselect-trigger:hover {
      border-color: hsl(214.3 31.8% 85%);
    }
    
    .multiselect-trigger:focus-within {
      outline: none;
      box-shadow: 0 0 0 2px hsl(221.2 83.2% 53.3%), 0 0 0 4px rgba(59, 130, 246, 0.1);
      border-color: transparent;
    }
    
    .multiselect-search-input {
      flex: 1;
      border: none;
      outline: none;
      background: transparent;
      font-size: 14px;
      padding: 0;
      min-width: 0;
    }
    
    .multiselect-search-input::placeholder {
      color: hsl(215.4 16.3% 46.9%);
    }
    
    .multiselect-dropdown {
      position: absolute;
      top: calc(100% + 4px);
      left: 0;
      right: 0;
      background: white;
      border: 1px solid hsl(214.3 31.8% 91.4%);
      border-radius: 6px;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      z-index: 50;
      max-height: 300px;
      overflow-y: auto;
      animation: slideDown 0.15s ease-out;
    }
    
    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-4px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .multiselect-options {
      padding: 4px;
    }
    
    .multiselect-option {
      display: flex;
      align-items: center;
      padding: 8px 12px;
      cursor: pointer;
      border-radius: 4px;
      transition: background-color 0.15s ease-in-out;
    }
    
    .multiselect-option:hover {
      background-color: hsl(210 40% 96.1%);
    }
    
    .multiselect-option input[type="checkbox"] {
      width: 16px;
      height: 16px;
      margin-right: 8px;
      cursor: pointer;
      accent-color: hsl(221.2 83.2% 53.3%);
    }
    
    .multiselect-option label {
      flex: 1;
      cursor: pointer;
      font-size: 14px;
      color: hsl(222.2 47.4% 11.2%);
      user-select: none;
    }
    
    .multiselect-option.hidden {
      display: none;
    }
    
    .multiselect-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 8px;
    }
    
    .multiselect-tag {
      display: inline-flex;
      align-items: center;
      padding: 4px 8px;
      background-color: hsl(210 40% 96.1%);
      border: 1px solid hsl(214.3 31.8% 91.4%);
      border-radius: 4px;
      font-size: 12px;
      color: hsl(222.2 47.4% 11.2%);
    }
    
    .multiselect-tag-remove {
      margin-left: 6px;
      cursor: pointer;
      color: hsl(215.4 16.3% 46.9%);
      font-weight: bold;
      line-height: 1;
      transition: color 0.15s ease-in-out;
    }
    
    .multiselect-tag-remove:hover {
      color: hsl(222.2 84% 4.9%);
    }
    
    .multiselect-chevron {
      width: 16px;
      height: 16px;
      color: hsl(215.4 16.3% 46.9%);
      transition: transform 0.2s ease-in-out;
      flex-shrink: 0;
      margin-left: 8px;
    }
    
    .multiselect-trigger.open .multiselect-chevron {
      transform: rotate(180deg);
    }
    
    .multiselect-empty {
      padding: 12px;
      text-align: center;
      color: hsl(215.4 16.3% 46.9%);
      font-size: 14px;
    }
  </style>
</head>
<body class="bg-slate-50">
  <div class="flex h-screen">
    <!-- Sidebar -->
    <aside 
      id="sidebar" 
      class="bg-white border-r border-slate-200 transition-all duration-300 ease-in-out flex flex-col w-72 shadow-sm overflow-hidden"
    >
      <!-- Header com Logo e Botão Colapsar -->
      <div class="flex items-center justify-between p-6 border-b border-slate-200 bg-slate-50/50 shadow-sm">
        <div id="logo-container" class="flex items-center space-x-2.5">
          <div id="logo-image-container" class="w-9 h-9 bg-blue-600 rounded-lg flex items-center justify-center shadow-sm overflow-hidden">
            <img id="logo-image" src="" alt="Logo" class="hidden w-full h-full object-contain" />
            <span id="logo-icon" class="text-white font-bold text-base">A</span>
          </div>
          <div id="logo-text" class="flex flex-col">
            <span id="logo-name" class="font-semibold text-slate-800 text-base">App</span>
            <span id="logo-subtitle" class="text-xs text-slate-500">Dashboard</span>
          </div>
        </div>
        
        <button
          id="btn-collapse"
          onclick="toggleSidebar()"
          class="p-1.5 rounded-md hover:bg-slate-100 transition-colors duration-150 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2"
          aria-label="Colapsar sidebar"
          title="Colapsar sidebar"
        >
          <svg id="icon-collapse" class="h-4 w-4 text-slate-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
          </svg>
        </button>
      </div>

      <!-- Campo de Busca -->
      <div id="search-container" class="px-4 py-3 border-b border-slate-200">
        <div class="relative">
          <svg class="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
          </svg>
          <input
            id="search-input"
            type="text"
            placeholder="Buscar..."
            oninput="handleSearch(this.value)"
            class="w-full pl-9 pr-4 py-2 bg-slate-50 border border-slate-200 rounded-md text-sm placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-1 focus:border-transparent transition-all duration-200"
          />
        </div>
      </div>

      <!-- Navegação -->
      <nav id="navigation" class="flex-1 px-4 py-2 overflow-y-auto sidebar-scroll">
        <ul id="menu-items" class="space-y-1">
          <!-- Itens do menu serão inseridos aqui via JavaScript -->
        </ul>
      </nav>

      <!-- Seção de Perfil -->
      <div class="mt-auto border-t border-slate-200 flex-shrink-0 overflow-hidden">
        <div id="profile-container" class="border-b border-slate-200 bg-slate-50/30 p-3">
          <div id="profile-expanded" class="relative">
            <button id="profile-button" onclick="toggleUserMenu()" class="w-full flex items-center px-3 py-2 rounded-lg bg-white hover:bg-slate-50 transition-colors duration-150 shadow-sm focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2">
              <div class="w-8 h-8 bg-slate-200 rounded-full flex items-center justify-center overflow-hidden flex-shrink-0">
                <img id="user-avatar" src="" alt="Avatar" class="hidden w-full h-full object-cover" />
                <span id="user-initials" class="text-slate-700 font-medium text-sm">JD</span>
              </div>
              <div class="flex-1 min-w-0 ml-2.5 text-left">
                <p id="user-name" class="text-sm font-medium text-slate-800 truncate">João Silva</p>
                <p id="user-email" class="text-xs text-slate-500 truncate">usuario@email.com</p>
              </div>
              <div class="w-2.5 h-2.5 bg-green-500 rounded-full ml-2 flex-shrink-0" title="Online" />
              <svg class="h-4 w-4 text-slate-400 ml-2 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
              </svg>
            </button>
            <!-- Dropdown do Menu do Usuário -->
            <div id="user-menu-dropdown" class="hidden absolute bottom-full left-0 right-0 mb-2 bg-white border border-slate-200 rounded-lg shadow-lg z-50 overflow-hidden">
              <!-- Itens do menu serão inseridos aqui via JavaScript -->
            </div>
          </div>
          
          <div id="profile-collapsed" class="hidden flex justify-center">
            <div class="relative tooltip">
              <button id="profile-button-collapsed" onclick="toggleUserMenu()" class="w-9 h-9 bg-slate-200 rounded-full flex items-center justify-center overflow-hidden shadow-sm focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2">
                <img id="user-avatar-collapsed" src="" alt="Avatar" class="hidden w-full h-full object-cover" />
                <span id="user-initials-collapsed" class="text-slate-700 font-medium text-sm">JD</span>
              </button>
              <div class="absolute -bottom-1 -right-1 w-2.5 h-2.5 bg-green-500 rounded-full border-2 border-white" />
              <div class="tooltip-content">
                <span id="tooltip-user-name">João Silva</span>
                <br>
                <span id="tooltip-user-email" class="text-xs opacity-75">usuario@email.com</span>
              </div>
            </div>
            <!-- Dropdown do Menu do Usuário (colapsado) -->
            <div id="user-menu-dropdown-collapsed" class="hidden absolute bottom-full left-0 mb-2 bg-white border border-slate-200 rounded-lg shadow-lg z-50 min-w-[200px] overflow-hidden">
              <!-- Itens do menu serão inseridos aqui via JavaScript -->
            </div>
          </div>
        </div>

      </div>
    </aside>

    <!-- Conteúdo Principal -->
    <main id="main-content" class="flex-1 transition-all duration-300 ease-in-out overflow-hidden">
      <div id="mitra-main-content" class="w-full h-full">
        <div id="mitra-initial-placeholder" class="flex flex-col items-center justify-center h-full text-slate-400">
          <svg class="w-12 h-12 mb-4 opacity-20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
          </svg>
          <p>Selecione um item no menu.</p>
        </div>
      </div>
    </main>
  </div>

  <!-- Botão FAB de Filtros -->
  <button
    id="filter-fab"
    onclick="toggleFilterModal()"
    class="fixed bottom-6 right-6 z-40 flex items-center justify-center w-14 h-14 bg-blue-600 text-white rounded-full shadow-lg hover:bg-blue-700 transition-all duration-200 hover:scale-110 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 hidden"
    aria-label="Abrir filtros"
    title="Filtros"
  >
    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z" />
    </svg>
    <span id="filter-badge" class="absolute -top-1 -right-1 flex items-center justify-center w-5 h-5 bg-red-500 text-white text-xs font-bold rounded-full hidden">0</span>
  </button>

  <!-- Backdrop do Modal -->
  <div
    id="filter-backdrop"
    onclick="closeFilterModal()"
    class="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 hidden transition-opacity duration-300"
  ></div>

  <!-- Modal Drawer de Filtros -->
  <div
    id="filter-drawer"
    class="fixed top-0 right-0 h-full w-full max-w-md bg-white shadow-2xl z-50 transform translate-x-full transition-transform duration-300 cubic-bezier(0.4, 0, 0.2, 1) flex flex-col"
  >
    <!-- Header -->
    <div class="flex items-center justify-between p-4 border-b border-slate-200 bg-slate-50/50 shadow-sm">
      <h2 id="filter-title" class="text-lg font-semibold text-slate-800">Filtros</h2>
      <button
        onclick="closeFilterModal()"
        class="p-2 rounded-md hover:bg-slate-100 transition-colors duration-150 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2"
        aria-label="Fechar filtros"
      >
        <svg class="w-5 h-5 text-slate-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
        </svg>
      </button>
    </div>

    <!-- Corpo Scrollável -->
    <div id="filter-content" class="flex-1 overflow-y-auto p-4 space-y-4">
      <div id="filter-empty" class="flex flex-col items-center justify-center h-full text-slate-400">
        <svg class="w-12 h-12 mb-4 opacity-20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z" />
        </svg>
        <p>Nenhum filtro disponível para esta tela.</p>
      </div>
    </div>

    <!-- Footer -->
    <div class="flex items-center justify-between gap-2 p-4 border-t border-slate-200 bg-slate-50/50">
      <button
        onclick="clearFilters()"
        class="px-4 py-2 text-sm font-medium text-slate-700 bg-white border border-slate-300 rounded-md hover:bg-slate-50 transition-colors duration-150 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2"
      >
        Limpar
      </button>
      <button
        onclick="applyFilters()"
        class="px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-md hover:bg-blue-700 transition-colors duration-150 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2"
      >
        Aplicar Filtros
      </button>
    </div>
  </div>

  <script>
    // Estado da sidebar
    let isCollapsed = false;
    let activeItemId = null;
    let menuItems = [];
    let filteredItems = [];
    let userMenuItems = [];
    let userMenuOpen = false;
    let menuGroups = {}; // Agrupa itens por grupo
    
    // Estado de filtros
    let currentScreenId = null;
    let filtersByScreen = {};
    let filterValues = {}; // Armazena valores dos filtros por campo
    
    // Debounce para busca
    let searchTimeout = null;
    
    // Cor primária personalizada
    let primaryColorValue = null;
    
    // Cache de elementos DOM frequentemente acessados
    const domCache = {
      get(id) {
        if (!this[id]) {
          this[id] = document.getElementById(id);
        }
        return this[id];
      },
      clear(id) {
        if (id) {
          delete this[id];
        } else {
          // Limpa todo o cache
          Object.keys(this).forEach(key => {
            if (key !== 'get' && key !== 'clear') {
              delete this[key];
            }
          });
        }
      }
    };

    /**
     * Extrai ID numérico de tela de URLs Mitra ou valores diretos
     * Suporta formato: "/embedded?inlineScreenId=123" ou apenas "123"
     */
    const resolveScreenId = (input) => {
      if (!input) return null;
      const str = String(input).trim();
      if (/^\d+$/.test(str)) return parseInt(str);
      const match = str.match(/[?&]inlineScreenId=(\d+)/);
      if (match && match[1]) return parseInt(match[1]);
      return null;
    };

    /**
     * Converte cor hex para RGBA
     * @param {string} hex - Cor em formato hex (ex: "#3B82F6" ou "3B82F6")
     * @param {number} alpha - Opacidade de 0 a 1 (ex: 0.3 para 30% de opacidade)
     * @returns {string} Cor em formato RGBA (ex: "rgba(59, 130, 246, 0.3)")
     */
    function hexToRgba(hex, alpha = 1) {
      // Remove # se presente
      hex = hex.replace('#', '');
      
      // Converte para RGB
      const r = parseInt(hex.substring(0, 2), 16);
      const g = parseInt(hex.substring(2, 4), 16);
      const b = parseInt(hex.substring(4, 6), 16);
      
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    /**
     * Converte cor hex para HSL
     * @param {string} hex - Cor em formato hex (ex: "#3B82F6" ou "3B82F6")
     * @returns {string} Cor em formato HSL (ex: "221.2 83.2% 53.3%")
     */
    function hexToHsl(hex) {
      // Remove # se presente
      hex = hex.replace('#', '');
      
      // Converte para RGB
      const r = parseInt(hex.substring(0, 2), 16) / 255;
      const g = parseInt(hex.substring(2, 4), 16) / 255;
      const b = parseInt(hex.substring(4, 6), 16) / 255;

      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      let h, s, l = (max + min) / 2;

      if (max === min) {
        h = s = 0; // achromatic
      } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
          case g: h = ((b - r) / d + 2) / 6; break;
          case b: h = ((r - g) / d + 4) / 6; break;
        }
      }

      h = Math.round(h * 360);
      s = Math.round(s * 100);
      l = Math.round(l * 100);

      return `${h} ${s}% ${l}%`;
    }

    /**
     * Aplica cor primária personalizada aos elementos do sidebar
     * @param {string} color - Cor em formato hex (ex: "#3B82F6")
     */
    function applyPrimaryColor(color) {
      if (!color) return;
      
      // Remove espaços e converte para formato consistente
      color = String(color).trim();
      
      // Se não começar com #, adiciona
      if (!color.startsWith('#')) {
        color = '#' + color;
      }
      
      // Valida formato hex
      if (!/^#[0-9A-Fa-f]{6}$/.test(color)) {
        console.warn('Formato de cor inválido. Use formato hex (ex: #3B82F6)');
        return;
      }
      
      // Armazena a cor globalmente
      primaryColorValue = color;
      
      // Converte para HSL
      const hsl = hexToHsl(color);
      
      // Atualiza variáveis CSS
      document.documentElement.style.setProperty('--primary', hsl);
      document.documentElement.style.setProperty('--ring', hsl);
      
      // Calcula variações da cor
      const lighter = lightenColor(color, 35); // Para bg ativo
      const light = lightenColor(color, 20); // Para bg-blue-100 equivalente
      const darker = darkenColor(color, 10); // Para hover states
      
      // Calcula cor com transparência para item ativo no modo colapsado (70% de transparência = 30% de opacidade)
      const primaryColorWithOpacity = hexToRgba(color, 0.1);
      
      // Adiciona estilo CSS dinâmico para classes que usam blue-*
      const styleId = 'dynamic-primary-color';
      let styleElement = document.getElementById(styleId);
      if (!styleElement) {
        styleElement = document.createElement('style');
        styleElement.id = styleId;
        document.head.appendChild(styleElement);
      }
      
      styleElement.textContent = `
        /* Logo container */
        #logo-image-container {
          background-color: ${color} !important;
        }
        
        /* FAB de filtros */
        #filter-fab {
          background-color: ${color} !important;
        }
        #filter-fab:hover {
          background-color: ${darker} !important;
        }
        
        /* Botão aplicar filtros */
        button[onclick="applyFilters()"] {
          background-color: ${color} !important;
        }
        button[onclick="applyFilters()"]:hover {
          background-color: ${darker} !important;
        }
        
        /* Item ativo no modo expandido - borda + background transparente (70% de transparência) */
        .menu-item.border-l-2:not(.collapsed-active) {
          border-left-color: ${color} !important;
          border-left-width: 2px !important;
          background-color: ${primaryColorWithOpacity} !important;
        }
        
        /* Item ativo no modo colapsado - sem borda, com background transparente (70% de transparência) */
        .menu-item.collapsed-active {
          border-left-width: 0 !important;
          background-color: ${primaryColorWithOpacity} !important;
        }
        
        /* Ícone ativo */
        .menu-item .text-blue-600,
        .menu-item.active .text-slate-500 {
          color: ${color} !important;
        }
        
        /* Submenu indicator ativo */
        .active-indicator {
          background-color: ${color} !important;
        }
        
        /* Submenu ativo - apenas borda */
        button[data-item-id].border-l-2 {
          border-left-color: ${color} !important;
          border-left-width: 2px !important;
        }
        
        /* Focus rings */
        .focus-visible\\:ring-blue-500:focus-visible,
        .focus\\:ring-blue-500:focus {
          --tw-ring-color: ${color} !important;
        }
        
        /* Input focus */
        input:focus,
        select:focus {
          --tw-ring-color: ${color} !important;
        }
      `;
      
      // Aplica cor diretamente nos elementos existentes
      updatePrimaryColorElements(color, darker);
    }

    /**
     * Atualiza elementos existentes com a cor primária
     * @param {string} color - Cor em formato hex
     * @param {string} darker - Cor escurecida para hover
     */
    function updatePrimaryColorElements(color, darker) {
      // Logo container
      const logoContainer = domCache.get('logo-image-container');
      if (logoContainer) {
        logoContainer.style.backgroundColor = color;
      }
      
      // FAB de filtros
      const filterFab = domCache.get('filter-fab');
      if (filterFab) {
        filterFab.style.backgroundColor = color;
      }
      
      // Botão aplicar filtros (será aplicado via CSS, mas garantimos aqui também)
      setTimeout(() => {
        const applyButton = document.querySelector('button[onclick="applyFilters()"]');
        if (applyButton) {
          applyButton.style.backgroundColor = color;
        }
      }, 100);
    }

    /**
     * Escurece uma cor hex
     * @param {string} hex - Cor em formato hex
     * @param {number} percent - Percentual para escurecer (0-100)
     * @returns {string} Cor escurecida em formato hex
     */
    function darkenColor(hex, percent) {
      hex = hex.replace('#', '');
      const r = parseInt(hex.substring(0, 2), 16);
      const g = parseInt(hex.substring(2, 4), 16);
      const b = parseInt(hex.substring(4, 6), 16);
      
      const newR = Math.max(0, Math.floor(r * (1 - percent / 100)));
      const newG = Math.max(0, Math.floor(g * (1 - percent / 100)));
      const newB = Math.max(0, Math.floor(b * (1 - percent / 100)));
      
      return '#' + [newR, newG, newB].map(x => {
        const hex = x.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      }).join('');
    }

    /**
     * Clareia uma cor hex
     * @param {string} hex - Cor em formato hex
     * @param {number} percent - Percentual para clarear (0-100)
     * @returns {string} Cor clareada em formato hex
     */
    function lightenColor(hex, percent) {
      hex = hex.replace('#', '');
      const r = parseInt(hex.substring(0, 2), 16);
      const g = parseInt(hex.substring(2, 4), 16);
      const b = parseInt(hex.substring(4, 6), 16);
      
      const newR = Math.min(255, Math.floor(r + (255 - r) * (percent / 100)));
      const newG = Math.min(255, Math.floor(g + (255 - g) * (percent / 100)));
      const newB = Math.min(255, Math.floor(b + (255 - b) * (percent / 100)));
      
      return '#' + [newR, newG, newB].map(x => {
        const hex = x.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      }).join('');
    }

    /**
     * Inicializa a sidebar com dados do componentData
     * Suporta tanto menuQuery (SQL) quanto menuItems (JSON)
     */
    async function initializeSidebar() {
      try {
        // Logo e nome da aplicação (suporta headerLogo, headerTitle, headerSubtitle)
        const logoUrl = componentData.headerLogo || componentData.logoImage;
        const logoTitle = componentData.headerTitle || componentData.logo;
        const logoSubtitle = componentData.headerSubtitle || componentData.logoSubtitle;
        
        if (logoUrl && logoUrl !== 'DEFAULTLOGO') {
          const logoImg = domCache.get('logo-image');
          logoImg.src = logoUrl;
          logoImg.classList.remove('hidden');
          domCache.get('logo-icon').classList.add('hidden');
        } else if (componentData.logoIcon) {
          domCache.get('logo-icon').textContent = componentData.logoIcon;
        }
        
        if (logoTitle) {
          domCache.get('logo-name').textContent = logoTitle;
        }
        if (logoSubtitle) {
          domCache.get('logo-subtitle').textContent = logoSubtitle;
        }

        // Carrega dados do usuário via userQuery ou userInfo
        await loadUserData();

        // Carrega itens do menu via menuQuery ou menuItems
        await loadMenuItems();

        // Carrega menu do usuário (userMenu)
        loadUserMenu();

        // Cor primária personalizada (se fornecida)
        if (componentData.primaryColor) {
          applyPrimaryColor(componentData.primaryColor);
        }

        // Estado inicial do item ativo (se fornecido)
        if (componentData.activeItemId) {
          activeItemId = componentData.activeItemId;
          updateActiveItem();
        }
      } catch (error) {
        console.error('Erro ao inicializar sidebar:', error);
      }
    }

    /**
     * Carrega dados do usuário via userQuery ou userInfo
     */
    async function loadUserData() {
      try {
        // Tenta carregar via userQuery (padrão do Menu nativo)
        if (componentData.userQuery) {
          const resultado = await queryMitra(componentData.userQuery);
          if (resultado && resultado.data && resultado.data.length > 0) {
            const userData = resultado.data[0]; // Primeira linha de dados
            const userNameCol = componentData.userName || 'NOME';
            const userEmailCol = componentData.userEmail || 'EMAIL';
            const userAvatarCol = componentData.userAvatar || 'FOTO_URL';
            
            // queryMitra retorna array de arrays
            // Assumindo ordem padrão: NOME, EMAIL, FOTO_URL
            // Ou mapeia pelos índices se a primeira linha for cabeçalho
            let name = '', email = '', avatar = '';
            
            if (Array.isArray(userData)) {
              // Se a primeira linha parece ser cabeçalho, pula ela
              const firstRow = resultado.data[0];
              const isHeader = firstRow.some(cell => typeof cell === 'string' && 
                (cell.toUpperCase() === userNameCol.toUpperCase() || 
                 cell.toUpperCase() === userEmailCol.toUpperCase()));
              
              const dataRow = isHeader && resultado.data.length > 1 ? resultado.data[1] : userData;
              
              // Tenta mapear pelos nomes das colunas se houver cabeçalho
              if (isHeader && Array.isArray(firstRow)) {
                const nameIdx = firstRow.findIndex(c => String(c).toUpperCase() === userNameCol.toUpperCase());
                const emailIdx = firstRow.findIndex(c => String(c).toUpperCase() === userEmailCol.toUpperCase());
                const avatarIdx = firstRow.findIndex(c => String(c).toUpperCase() === userAvatarCol.toUpperCase());
                
                if (nameIdx >= 0 && dataRow[nameIdx] !== undefined) name = String(dataRow[nameIdx] || '');
                if (emailIdx >= 0 && dataRow[emailIdx] !== undefined) email = String(dataRow[emailIdx] || '');
                if (avatarIdx >= 0 && dataRow[avatarIdx] !== undefined) avatar = String(dataRow[avatarIdx] || '');
              } else {
                // Ordem padrão: primeira coluna = nome, segunda = email, terceira = avatar
                name = String(dataRow[0] || '');
                email = String(dataRow[1] || '');
                avatar = String(dataRow[2] || '');
              }
            }
            
            updateUserDisplay(name, email, avatar);
            return;
          }
        }
        
        // Fallback para userInfo (JSON)
        if (componentData.userInfo) {
          const userInfo = JSON.parse(componentData.userInfo);
          updateUserDisplay(
            userInfo.name || '',
            userInfo.email || userInfo.role || '',
            userInfo.avatar || userInfo.photo || ''
          );
        }
      } catch (error) {
        console.error('Erro ao carregar dados do usuário:', error);
      }
    }

    /**
     * Atualiza exibição dos dados do usuário
     */
    function updateUserDisplay(name, email, avatar) {
      if (name) {
        domCache.get('user-name').textContent = name;
        domCache.get('tooltip-user-name').textContent = name;
        
        // Gera iniciais se não houver avatar
        if (!avatar && name) {
          const initials = name.split(' ').map(n => n[0]).join('').substring(0, 2).toUpperCase();
          domCache.get('user-initials').textContent = initials;
          domCache.get('user-initials-collapsed').textContent = initials;
        }
      }
      
      if (email) {
        domCache.get('user-email').textContent = email;
        domCache.get('tooltip-user-email').textContent = email;
      }
      
      if (avatar) {
        const avatarImg = domCache.get('user-avatar');
        const avatarImgCollapsed = domCache.get('user-avatar-collapsed');
        avatarImg.src = avatar;
        avatarImg.classList.remove('hidden');
        avatarImgCollapsed.src = avatar;
        avatarImgCollapsed.classList.remove('hidden');
        domCache.get('user-initials').classList.add('hidden');
        domCache.get('user-initials-collapsed').classList.add('hidden');
      }
    }

    /**
     * Carrega itens do menu via menuQuery (SQL) ou menuItems (JSON)
     */
    async function loadMenuItems() {
      try {
        // Prioridade: menuQuery (padrão do Menu nativo)
        if (componentData.menuQuery) {
          const resultado = await queryMitra(componentData.menuQuery);
          if (resultado && resultado.data) {
            menuItems = parseMenuQueryResult(resultado.data);
            filteredItems = [...menuItems];
            renderMenuItems();
            return;
          }
        }
        
        // Fallback para menuItems (JSON)
        if (componentData.menuItems) {
          menuItems = JSON.parse(componentData.menuItems);
          filteredItems = [...menuItems];
          renderMenuItems();
        }
      } catch (error) {
        console.error('Erro ao carregar itens do menu:', error);
      }
    }

    /**
     * Parse do resultado da query SQL do menu
     * Mapeia colunas conforme configuração do componentData
     * queryMitra retorna { data: [[valor1, valor2, ...], ...] } - array de arrays
     */
    function parseMenuQueryResult(data) {
      if (!data || data.length === 0) return [];
      
      // Obtém nomes das colunas do mapeamento (nomes das colunas na query SQL)
      const idCol = componentData.menuIdColumn || 'ID';
      const nameCol = componentData.menuNameColumn || 'NAME';
      const iconCol = componentData.menuIconColumn || 'ICON';
      const groupCol = componentData.menuGroupColumn || 'GRUPO';
      const parentIdCol = componentData.menuParentIdColumn || 'PARENTID';
      const urlCol = componentData.menuUrlColumn || 'MENUURL';
      
      // queryMitra retorna array de arrays, então precisamos mapear pelos índices
      // Assumindo ordem padrão: ID, NAME, ICON, GRUPO, PARENTID, MENUURL
      // Mas pode variar conforme a query, então tentamos mapear pelo nome da coluna
      const items = [];
      const itemsMap = {}; // Para construir hierarquia
      
      // Tenta detectar ordem das colunas pela primeira linha
      // Se a primeira linha contém cabeçalhos, usa-os; senão assume ordem padrão
      let columnOrder = {};
      let startIndex = 0;
      
      // Lista de nomes de colunas esperados (em maiúsculas para comparação)
      const expectedColumns = [
        idCol.toUpperCase(),
        nameCol.toUpperCase(),
        iconCol.toUpperCase(),
        groupCol.toUpperCase(),
        parentIdCol.toUpperCase(),
        urlCol.toUpperCase()
      ];
      
      // Verifica se a primeira linha corresponde aos nomes das colunas esperados
      if (data.length > 0 && Array.isArray(data[0])) {
        const firstRow = data[0];
        // Converte primeira linha para strings e maiúsculas para comparação
        const firstRowUpper = firstRow.map(cell => String(cell).toUpperCase().trim());
        
        // Verifica se pelo menos 3 colunas da primeira linha correspondem aos nomes esperados
        // Isso evita falsos positivos quando dados reais estão em maiúsculas
        const matchingColumns = firstRowUpper.filter(col => expectedColumns.includes(col)).length;
        const isHeader = matchingColumns >= 3;
        
        if (isHeader) {
          // Primeira linha é cabeçalho, mapeia índices
          firstRow.forEach((colName, idx) => {
            const colUpper = String(colName).toUpperCase().trim();
            if (colUpper === idCol.toUpperCase()) columnOrder.id = idx;
            if (colUpper === nameCol.toUpperCase()) columnOrder.name = idx;
            if (colUpper === iconCol.toUpperCase()) columnOrder.icon = idx;
            if (colUpper === groupCol.toUpperCase()) columnOrder.group = idx;
            if (colUpper === parentIdCol.toUpperCase()) columnOrder.parentId = idx;
            if (colUpper === urlCol.toUpperCase()) columnOrder.url = idx;
          });
          startIndex = 1; // Pula cabeçalho
        } else {
          // Assume ordem padrão: ID, NAME, ICON, GRUPO, PARENTID, MENUURL
          columnOrder = { id: 0, name: 1, icon: 2, group: 3, parentId: 4, url: 5 };
        }
      }
      
      // Processa cada linha de dados
      for (let i = startIndex; i < data.length; i++) {
        const row = data[i];
        if (!Array.isArray(row) || row.length === 0) continue;
        
        const item = {
          id: String(row[columnOrder.id] ?? row[0] ?? i),
          label: String(row[columnOrder.name] ?? row[1] ?? ''),
          icon: String(row[columnOrder.icon] ?? row[2] ?? 'home'),
          group: String(row[columnOrder.group] ?? row[3] ?? ''),
          parentId: String(row[columnOrder.parentId] ?? row[4] ?? ''),
          url: String(row[columnOrder.url] ?? row[5] ?? '')
        };
        
        // Valida se o item tem pelo menos ID e label antes de adicionar
        if (!item.id || (!item.label || !item.label.trim())) {
          console.warn(`Item na linha ${i} ignorado por falta de ID ou label:`, item);
          continue;
        }
        
        // A normalização do ícone é feita na função getIconSVG()
        // Mantém o valor original da query para permitir flexibilidade
        
        // Processa URL se for do formato Mitra (embedded)
        if (item.url && item.url.includes('/embedded')) {
          item.navigationType = 'iframe';
        }
        
        itemsMap[item.id] = item;
        items.push(item);
      }
      
      // Debug: log do número de itens processados
      console.log(`parseMenuQueryResult: processados ${items.length} itens (startIndex: ${startIndex}, total linhas: ${data.length})`);
      
      // Constrói hierarquia de submenus
      const rootItems = [];
      items.forEach(item => {
        if (!item.parentId || item.parentId === '' || item.parentId === null || item.parentId === 'NULL') {
          rootItems.push(item);
        } else {
          const parent = itemsMap[item.parentId];
          if (parent) {
            if (!parent.submenu) parent.submenu = [];
            parent.submenu.push(item);
          } else {
            rootItems.push(item); // Se parent não encontrado, adiciona como root
          }
        }
      });
      
      return rootItems;
    }

    /**
     * Carrega menu do usuário (userMenu)
     */
    function loadUserMenu() {
      try {
        if (componentData.userMenu) {
          userMenuItems = JSON.parse(componentData.userMenu);
          renderUserMenu();
        }
      } catch (error) {
        console.error('Erro ao carregar menu do usuário:', error);
      }
    }

    /**
     * Renderiza menu dropdown do usuário
     */
    function renderUserMenu() {
      const dropdownExpanded = domCache.get('user-menu-dropdown');
      const dropdownCollapsed = domCache.get('user-menu-dropdown-collapsed');
      
      if (!userMenuItems || userMenuItems.length === 0) return;
      
      const menuHTML = userMenuItems.map(item => {
        const iconName = (item.icone || item.icon || 'User').toLowerCase();
        return `
          <button
            onclick="handleUserMenuAction('${item.tipoInteracao}', ${item.idInteracao})"
            class="w-full flex items-center space-x-2 px-4 py-2 text-left text-sm text-slate-700 hover:bg-slate-50 transition-colors duration-150 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-1 ${
              item.nome === 'Sair' ? 'text-red-600 hover:bg-red-50' : ''
            }"
          >
            ${getIconSVG(iconName, false)}
            <span>${item.nome}</span>
          </button>
        `;
      }).join('');
      
      dropdownExpanded.innerHTML = menuHTML;
      dropdownCollapsed.innerHTML = menuHTML;
    }

    /**
     * Manipula ações do menu do usuário
     */
    async function handleUserMenuAction(tipoInteracao, idInteracao) {
      toggleUserMenu(); // Fecha o menu
      
      try {
        if (tipoInteracao === 'action') {
          actionMitra({ id: parseInt(idInteracao) });
        } else if (tipoInteracao === 'form') {
          // Abre formulário (pode precisar de implementação específica)
          console.log('Abrir formulário:', idInteracao);
        } else if (tipoInteracao === 'modal') {
          modalMitra({ id: parseInt(idInteracao), width: 80, height: 90 });
        }
      } catch (error) {
        console.error('Erro ao executar ação do menu do usuário:', error);
      }
    }

    /**
     * Alterna menu do usuário (abre/fecha dropdown)
     */
    function toggleUserMenu() {
      userMenuOpen = !userMenuOpen;
      const dropdownExpanded = domCache.get('user-menu-dropdown');
      const dropdownCollapsed = domCache.get('user-menu-dropdown-collapsed');
      
      if (isCollapsed) {
        dropdownCollapsed.classList.toggle('hidden', !userMenuOpen);
      } else {
        dropdownExpanded.classList.toggle('hidden', !userMenuOpen);
      }
    }

    // Fecha menu do usuário ao clicar fora
    document.addEventListener('click', (e) => {
      if (!e.target.closest('#profile-container')) {
        userMenuOpen = false;
        domCache.get('user-menu-dropdown').classList.add('hidden');
        domCache.get('user-menu-dropdown-collapsed').classList.add('hidden');
      }
      
      // Fecha multiselects ao clicar fora
      if (!e.target.closest('.multiselect-container')) {
        document.querySelectorAll('.multiselect-dropdown').forEach(dropdown => {
          dropdown.classList.add('hidden');
        });
        document.querySelectorAll('.multiselect-trigger').forEach(trigger => {
          trigger.classList.remove('open');
        });
      }
    });

    /**
     * Renderiza os itens do menu
     * Suporta agrupamento por grupos
     */
    function renderMenuItems() {
      const menuContainer = domCache.get('menu-items');
      menuContainer.innerHTML = '';

      // Agrupa itens por grupo se menuGroupColumn estiver configurado
      if (componentData.menuGroupColumn) {
        menuGroups = {};
        filteredItems.forEach(item => {
          const group = item.group || 'Outros';
          if (!menuGroups[group]) menuGroups[group] = [];
          menuGroups[group].push(item);
        });
        
        // Renderiza grupos
        Object.keys(menuGroups).forEach((groupName, index) => {
          // Só renderiza cabeçalho de grupo se não estiver colapsado
          if (groupName && groupName !== 'Outros' && !isCollapsed) {
            const groupHeader = document.createElement('li');
            groupHeader.className = index > 0 ? 'px-4 py-2 mt-4 border-t border-slate-100' : 'px-4 py-2 mt-2';
            groupHeader.innerHTML = `
              <span class="text-xs font-semibold text-slate-500 uppercase tracking-wider">${groupName}</span>
            `;
            menuContainer.appendChild(groupHeader);
          }
          
          menuGroups[groupName].forEach(item => {
            menuContainer.appendChild(createMenuItemElement(item));
          });
        });
      } else {
        // Renderiza sem agrupamento
        filteredItems.forEach(item => {
          menuContainer.appendChild(createMenuItemElement(item));
        });
      }
    }

    /**
     * Cria elemento HTML para um item do menu
     */
    function createMenuItemElement(item) {
      const li = document.createElement('li');
      const hasSubmenu = item.submenu && item.submenu.length > 0;
      const isActive = activeItemId === item.id;
      const isSubmenuOpen = item.submenuOpen || false;
      const itemLabel = item.label || item.name || '';
      const itemIcon = item.icon || 'home';
      const itemBadge = item.badge || '';

      // Determina classes do botão baseado no estado (ativo e colapsado)
      let buttonClasses = 'menu-item w-full flex items-center space-x-2.5 px-4 py-2.5 rounded-lg text-left transition-colors duration-200 group focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2';
      
      if (isCollapsed) {
        buttonClasses += ' justify-center px-2';
        if (isActive) {
          // Modo colapsado e ativo: sem borda, com background transparente
          buttonClasses += ' collapsed-active font-medium text-slate-900';
        } else {
          buttonClasses += ' text-slate-600 hover:bg-slate-100/50 hover:text-slate-900';
        }
      } else {
        // Modo expandido
        if (isActive) {
          buttonClasses += ' border-l-2 border-blue-600 font-medium text-slate-900';
        } else {
          buttonClasses += ' text-slate-600 hover:bg-slate-100/50 hover:text-slate-900';
        }
      }

      li.innerHTML = `
          <div class="relative ${isCollapsed ? 'tooltip' : ''}">
            <button
              onclick="handleMenuItemClick('${item.id}')"
              class="${buttonClasses}"
              data-item-id="${item.id}"
              ${isActive ? 'aria-current="page"' : ''}
            >
              <div class="flex items-center justify-center min-w-[24px]">
                ${getIconSVG(itemIcon, isActive)}
              </div>
              
              ${!isCollapsed ? `
                <div class="flex items-center justify-between w-full">
                  <span class="text-sm ${isActive ? 'font-medium' : 'font-normal'}">${itemLabel}</span>
                  ${itemBadge ? `
                    <span class="px-2 py-0.5 text-xs font-medium rounded-md ${
                      isActive ? 'bg-slate-100 text-slate-700' : 'bg-slate-100 text-slate-600'
                    }">
                      ${itemBadge}
                    </span>
                  ` : ''}
                  ${hasSubmenu ? `
                    <svg class="h-4 w-4 text-slate-400 transition-transform duration-200 ${isSubmenuOpen ? 'rotate-90' : ''}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                    </svg>
                  ` : ''}
                </div>
              ` : ''}

              ${isCollapsed && itemBadge ? `
                <div class="absolute top-1 right-1 w-4 h-4 flex items-center justify-center rounded-md bg-slate-100 border border-white">
                  <span class="text-[10px] font-medium text-slate-700">
                    ${parseInt(itemBadge) > 9 ? '9+' : itemBadge}
                  </span>
                </div>
              ` : ''}

              ${isCollapsed ? `
                <div class="tooltip-content">
                  ${itemLabel}
                  ${itemBadge ? `<span class="ml-1.5 px-1 py-0.5 bg-slate-700 rounded-md text-[10px]">${itemBadge}</span>` : ''}
                </div>
              ` : ''}
            </button>
          </div>
          ${hasSubmenu && !isCollapsed ? `
            <div id="submenu-${item.id}" class="ml-6 mt-1 bg-slate-50/30 rounded-lg p-1 ${isSubmenuOpen ? '' : 'hidden'}">
              ${renderSubmenu(item.submenu, item.id)}
            </div>
          ` : ''}
      `;

      return li;
    }

    /**
     * Renderiza submenu
     */
    function renderSubmenu(submenuItems, parentId) {
      return submenuItems.map(subItem => {
        const isActive = activeItemId === subItem.id;
        return `
          <button
            onclick="handleMenuItemClick('${subItem.id}', '${parentId}')"
            class="w-full flex items-center space-x-2 px-3 py-2 rounded-md text-left transition-colors duration-200 text-sm focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-1 ${
              isActive ? 'border-l-2 border-blue-600 text-slate-900 font-medium' : 'text-slate-600 hover:bg-slate-100/50'
            }"
            data-item-id="${subItem.id}"
            ${isActive ? 'aria-current="page"' : ''}
          >
            <div class="w-1 h-1 rounded-full bg-slate-400 ${isActive ? (primaryColorValue ? 'active-indicator' : 'bg-blue-600') : ''}"></div>
            <span>${subItem.label}</span>
            ${subItem.badge ? `
              <span class="ml-auto px-2 py-0.5 text-xs font-medium rounded-md bg-slate-100 text-slate-600">
                ${subItem.badge}
              </span>
            ` : ''}
          </button>
        `;
      }).join('');
    }

    /**
     * Definição de ícones SVG (Lucide)
     * Organizado em objeto separado para facilitar manutenção
     */
    const iconDefinitions = {
      home: (iconClass) => `<svg class="${iconClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" />
      </svg>`,
      dashboard: (iconClass) => `<svg class="${iconClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
      </svg>`,
      user: (iconClass) => `<svg class="${iconClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
      </svg>`,
      settings: (iconClass) => `<svg class="${iconClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
      </svg>`,
      bell: (iconClass) => `<svg class="${iconClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9" />
      </svg>`,
      file: (iconClass) => `<svg class="${iconClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
      </svg>`,
      chart: (iconClass) => `<svg class="${iconClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
      </svg>`,
      logout: (iconClass) => `<svg class="${iconClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" />
      </svg>`,
      layoutdashboard: (iconClass) => `<svg class="${iconClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
      </svg>`,
      users: (iconClass) => `<svg class="${iconClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197M13 7a4 4 0 11-8 0 4 4 0 018 0z" />
      </svg>`,
      piechart: (iconClass) => `<svg class="${iconClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 3.055A9.001 9.001 0 1020.945 13H11V3.055z" />
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.488 9H15V3.512A9.025 9.025 0 0120.488 9z" />
      </svg>`,
      history: (iconClass) => `<svg class="${iconClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
      </svg>`,
      calendardays: (iconClass) => `<svg class="${iconClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
      </svg>`,
      calendar: (iconClass) => `<svg class="${iconClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
      </svg>`,
      trendingup: (iconClass) => `<svg class="${iconClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6" />
      </svg>`,
      filechart: (iconClass) => `<svg class="${iconClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
      </svg>`,
      shieldcheck: (iconClass) => `<svg class="${iconClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" />
      </svg>`,
      edit: (iconClass) => `<svg class="${iconClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
      </svg>`
    };

    /**
     * Retorna SVG do ícone baseado no nome
     * Suporta ícones em PascalCase (Lucide) convertendo para lowercase
     */
    function getIconSVG(iconName, isActive = false) {
      let iconClass;
      if (isActive && primaryColorValue) {
        // Se tem cor primária personalizada e está ativo, usa estilo inline
        iconClass = 'h-4.5 w-4.5 flex-shrink-0';
      } else {
        iconClass = `h-4.5 w-4.5 flex-shrink-0 ${isActive ? 'text-blue-600' : 'text-slate-500 group-hover:text-slate-700'}`;
      }
      
      // Converte PascalCase para lowercase (ex: LayoutDashboard -> layoutdashboard)
      // Remove espaços e converte tudo para lowercase
      const normalizedName = String(iconName || 'home')
        .replace(/([A-Z])/g, (match) => match.toLowerCase())
        .toLowerCase()
        .replace(/\s+/g, '');
      
      const iconFn = iconDefinitions[normalizedName];
      let svg = iconFn ? iconFn(iconClass) : iconDefinitions.home(iconClass);
      
      // Se tem cor primária e está ativo, aplica cor inline
      if (isActive && primaryColorValue) {
        svg = svg.replace('currentColor', primaryColorValue);
      }
      
      return svg;
    }

    /**
     * Alterna estado colapsado/expandido da sidebar
     * Otimizado para evitar recarregamento do iframe durante a transição
     */
    function toggleSidebar() {
      isCollapsed = !isCollapsed;
      const sidebar = domCache.get('sidebar');
      const logoText = domCache.get('logo-text');
      const searchContainer = domCache.get('search-container');
      const profileExpanded = domCache.get('profile-expanded');
      const profileCollapsed = domCache.get('profile-collapsed');
      const iconCollapse = domCache.get('icon-collapse');
      const mainContent = domCache.get('main-content');

      const navigation = domCache.get('navigation');
      
      // Adiciona classe de transição para otimizar performance
      mainContent.classList.add('transitioning');
      
      if (isCollapsed) {
        sidebar.classList.remove('w-72');
        sidebar.classList.add('w-20');
        logoText.classList.add('hidden');
        searchContainer.classList.add('hidden');
        profileExpanded.classList.add('hidden');
        profileCollapsed.classList.remove('hidden');
        iconCollapse.classList.add('rotate-180');
        
        // Esconde scrollbar mas mantém scroll funcional
        navigation.classList.remove('sidebar-scroll');
        navigation.classList.add('sidebar-scroll-hidden');
        
        // Adiciona tooltips aos itens do menu
        document.querySelectorAll('.menu-item').forEach(item => {
          item.classList.add('tooltip');
        });
      } else {
        sidebar.classList.remove('w-20');
        sidebar.classList.add('w-72');
        logoText.classList.remove('hidden');
        searchContainer.classList.remove('hidden');
        profileExpanded.classList.remove('hidden');
        profileCollapsed.classList.add('hidden');
        iconCollapse.classList.remove('rotate-180');
        
        // Mostra scrollbar quando expandido
        navigation.classList.remove('sidebar-scroll-hidden');
        navigation.classList.add('sidebar-scroll');
        
        // Remove tooltips dos itens do menu
        document.querySelectorAll('.menu-item').forEach(item => {
          item.classList.remove('tooltip');
        });
      }

      renderMenuItems();
      
      // Remove classe de transição após a animação (300ms + margem de segurança)
      setTimeout(() => {
        mainContent.classList.remove('transitioning');
      }, 350);
    }

    /**
     * Manipula clique em item do menu
     */
    async function handleMenuItemClick(itemId, parentId = null) {
      const item = findMenuItem(itemId, menuItems);
      
      if (!item) {
        console.error(`Item de menu não encontrado: ${itemId}`);
        return;
      }

      // Se tem submenu, apenas expande/recolhe
      if (item.submenu && item.submenu.length > 0 && !parentId) {
        toggleSubmenu(itemId);
        return;
      }

      // Define item ativo
      activeItemId = itemId;
      updateActiveItem();

      // Navega usando funções Mitra
      await handleNavigation(item);
    }

    /**
     * Encontra item do menu recursivamente
     */
    function findMenuItem(itemId, items) {
      for (const item of items) {
        if (item.id == itemId) {
          return item;
        }
        if (item.submenu) {
          const found = findMenuItem(itemId, item.submenu);
          if (found) return found;
        }
      }
      return null;
    }

    /**
     * Alterna submenu expandido/recolhido
     */
    function toggleSubmenu(itemId) {
      const item = findMenuItem(itemId, menuItems);
      if (item && item.submenu) {
        item.submenuOpen = !item.submenuOpen;
        renderMenuItems();
      }
    }

    /**
     * Atualiza visual do item ativo
     */
    function updateActiveItem() {
      renderMenuItems();
    }

    /**
     * Manipula busca/filtro de itens
     * Com debounce para melhorar performance
     */
    function handleSearch(term) {
      // Limpa timeout anterior
      if (searchTimeout) {
        clearTimeout(searchTimeout);
      }
      
      // Aplica debounce de 300ms
      searchTimeout = setTimeout(() => {
        const searchTerm = term.toLowerCase().trim();
        
        if (!searchTerm) {
          filteredItems = [...menuItems];
        } else {
          filteredItems = menuItems.filter(item => {
            const matchesLabel = item.label.toLowerCase().includes(searchTerm);
            const matchesSubmenu = item.submenu && item.submenu.some(subItem => 
              subItem.label.toLowerCase().includes(searchTerm)
            );
            return matchesLabel || matchesSubmenu;
          });
        }
        
        renderMenuItems();
      }, 300);
    }

    /**
     * Navega usando funções nativas do Mitra
     * Carrega telas Mitra em iframe interno usando modalMitra com parâmetro parent
     * Compatível com formato do Menu nativo (URLs embedded)
     */
    async function handleNavigation(item) {
      try {
        // Define variável de contexto se necessário
        if (item.contextVariable) {
          await setVariableMitra({ 
            name: item.contextVariable, 
            content: item.contextValue || item.id 
          });
        }

        // Extrai screenId da URL ou do campo screenId
        const screenId = resolveScreenId(item.url) || resolveScreenId(item.screenId);

        if (screenId) {
          // Atualiza tela atual para sistema de filtros
          currentScreenId = screenId;
          updateFilterFabVisibility();
          
          // Recarrega a tela usando função centralizada
          await reloadCurrentScreen();
          return;
        }

        // Fallback: actionId (navegação via Action)
        if (item.actionId) {
          const actionId = parseInt(item.actionId);
          actionMitra({ id: actionId });
          return;
        }

        // Fallback: query (para casos especiais)
        if (item.query) {
          const resultado = await queryMitra(item.query);
          if (item.onQueryResult && typeof window[item.onQueryResult] === 'function') {
            window[item.onQueryResult](resultado);
          }
        }
      } catch (error) {
        console.error(`Erro ao navegar para ${item.label || item.name}:`, error);
      }
    }

    /**
     * Recarrega a tela atual (hard reset do container)
     * Centraliza a lógica de recarregamento para evitar duplicação
     */
    async function reloadCurrentScreen() {
      if (!currentScreenId) return;
      
      const mainWrapper = domCache.get('main-content');
      const oldContainer = domCache.get('mitra-main-content');
      if (oldContainer) oldContainer.remove();
      
      const newContainer = document.createElement('div');
      newContainer.id = 'mitra-main-content';
      newContainer.className = 'w-full h-full';
      mainWrapper.appendChild(newContainer);
      
      try {
        await modalMitra({ id: currentScreenId, parent: 'mitra-main-content', width: 100, height: 100 });
      } catch (e) {
        console.error("Erro ao recarregar tela Mitra:", e);
        newContainer.innerHTML = `<div class="flex h-full items-center justify-center text-red-500">Erro ao carregar</div>`;
      }
    }

    /**
     * Manipula logout (mantido para compatibilidade)
     * O logout agora é gerenciado via userMenu
     */
    async function handleLogout() {
      // Busca ação de logout no userMenu
      const logoutAction = userMenuItems.find(item => 
        item.nome === 'Sair' || item.nome === 'Logout'
      );
      
      if (logoutAction) {
        await handleUserMenuAction(logoutAction.tipoInteracao, logoutAction.idInteracao);
        return;
      }
      
      // Fallback para actionLogoutId (compatibilidade)
      if (componentData.actionLogoutId) {
        const actionId = parseInt(componentData.actionLogoutId);
        actionMitra({ id: actionId });
      } else {
        console.error('Ação de logout não configurada. Configure userMenu com ação "Sair" ou actionLogoutId.');
      }
    }

    /**
     * Sistema de Filtros por Tela
     */

    /**
     * Carrega configuração de filtros do componentData
     * Suporta dois formatos:
     * 1. Array de objetos: [{"id": "10", "title": "...", "fields": [...]}]
     * 2. Objeto com IDs como chaves: {"10": {"title": "...", "fields": [...]}} (compatibilidade)
     */
    function loadFilterConfig() {
      try {
        if (componentData.filtersByScreen) {
          const parsed = JSON.parse(componentData.filtersByScreen);
          
          // Se for array, converte para objeto indexado por ID
          if (Array.isArray(parsed)) {
            filtersByScreen = {};
            parsed.forEach(config => {
              if (config.id) {
                filtersByScreen[config.id] = {
                  title: config.title,
                  fields: config.fields || []
                };
              }
            });
          } else {
            // Formato antigo (objeto com IDs como chaves) - mantém compatibilidade
            filtersByScreen = parsed;
          }
        }
      } catch (error) {
        console.error('Erro ao carregar configuração de filtros:', error);
        filtersByScreen = {};
      }
    }

    /**
     * Obtém configuração de filtros para a tela atual
     * @returns {Object|null} Configuração de filtros ou null
     */
    function getFilterConfig() {
      return currentScreenId ? filtersByScreen[currentScreenId] : null;
    }

    /**
     * Atualiza visibilidade do FAB baseado na tela atual
     */
    function updateFilterFabVisibility() {
      const fab = domCache.get('filter-fab');
      if (!fab) return;
      
      if (getFilterConfig()) {
        fab.classList.remove('hidden');
        updateFilterBadge();
      } else {
        fab.classList.add('hidden');
      }
    }

    /**
     * Abre o modal de filtros
     */
    async function toggleFilterModal() {
      const drawer = domCache.get('filter-drawer');
      const backdrop = domCache.get('filter-backdrop');
      
      if (drawer.classList.contains('translate-x-full')) {
        // Abre
        drawer.classList.remove('translate-x-full');
        backdrop.classList.remove('hidden');
        // Renderiza campos inicialmente (vazios)
        await loadFilterFields();
        // Carrega valores salvos das variáveis :VAR_
        await loadFilterValues();
        // Re-renderiza campos com valores carregados
        await loadFilterFields();
        // Atualiza badge com quantidade de filtros ativos
        updateFilterBadge();
      } else {
        // Fecha
        closeFilterModal();
      }
    }

    /**
     * Fecha o modal de filtros
     */
    function closeFilterModal() {
      const drawer = domCache.get('filter-drawer');
      const backdrop = domCache.get('filter-backdrop');
      
      drawer.classList.add('translate-x-full');
      backdrop.classList.add('hidden');
    }

    /**
     * Carrega e renderiza campos de filtro para a tela atual
     */
    async function loadFilterFields() {
      const content = domCache.get('filter-content');
      const empty = domCache.get('filter-empty');
      const title = domCache.get('filter-title');
      
      if (!currentScreenId || !filtersByScreen[currentScreenId]) {
        content.innerHTML = '';
        empty.classList.remove('hidden');
        title.textContent = 'Filtros';
        return;
      }

      empty.classList.add('hidden');
      const config = filtersByScreen[currentScreenId];
      title.textContent = config.title || 'Filtros';
      
      // Mostra loading enquanto carrega campos com queries
      content.innerHTML = '<div class="flex items-center justify-center py-8"><div class="text-sm text-slate-500">Carregando filtros...</div></div>';
      
      let html = '';
      
      // Processa campos sequencialmente para aguardar queries
      for (const field of config.fields) {
        switch (field.type) {
          case 'text':
            html += renderTextField(field);
            break;
          case 'select':
            // Se tiver optionsQuery, carrega opções dinamicamente
            if (field.optionsQuery) {
              try {
                const options = await loadSelectOptions(field);
                html += renderSelectField(field, options);
              } catch (error) {
                console.error(`Erro ao carregar opções do campo ${field.id}:`, error);
                // Renderiza select vazio em caso de erro
                html += renderSelectField(field, []);
              }
            } else {
              // Usa opções estáticas
              html += renderSelectField(field, field.options || []);
            }
            break;
          case 'multiselect':
            // Se tiver optionsQuery, carrega opções dinamicamente
            if (field.optionsQuery) {
              try {
                const options = await loadSelectOptions(field);
                html += renderMultiSelectField(field, options);
              } catch (error) {
                console.error(`Erro ao carregar opções do campo ${field.id}:`, error);
                // Renderiza multiselect vazio em caso de erro
                html += renderMultiSelectField(field, []);
              }
            } else {
              // Usa opções estáticas
              html += renderMultiSelectField(field, field.options || []);
            }
            break;
          case 'checkbox':
            html += renderCheckboxField(field);
            break;
          case 'dateRange':
            html += renderDateRangeField(field);
            break;
          case 'year':
            // Se tiver optionsQuery, carrega opções dinamicamente
            if (field.optionsQuery) {
              try {
                const options = await loadSelectOptions(field);
                html += renderYearField(field, options);
              } catch (error) {
                console.error(`Erro ao carregar opções do campo ${field.id}:`, error);
                html += renderYearField(field, []);
              }
            } else {
              // Usa opções estáticas se fornecidas
              html += renderYearField(field, field.options || []);
            }
            break;
          case 'month':
            html += renderMonthField(field);
            break;
        }
      }
      
      content.innerHTML = html;
    }

    /**
     * Renderiza campo de texto
     */
    function renderTextField(field) {
      const value = filterValues[field.id] || '';
      return `
        <div class="space-y-2">
          <label class="block text-sm font-medium text-slate-700">${field.label}</label>
          <input
            type="text"
            id="filter-${field.id}"
            data-field-type="text"
            data-variable="${field.variable}"
            placeholder="${field.placeholder || ''}"
            value="${value}"
            class="w-full px-3 py-2 border border-slate-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-1 focus:border-transparent transition-all duration-200"
          />
        </div>
      `;
    }

    /**
     * Carrega opções de um campo select via query SQL
     * @param {Object} field - Configuração do campo com optionsQuery
     * @returns {Promise<Array>} Array de opções no formato {value, label}
     */
    async function loadSelectOptions(field) {
      if (!field.optionsQuery) {
        return [];
      }
      
      try {
        const resultado = await queryMitra(field.optionsQuery);
        if (!resultado || !resultado.data || resultado.data.length === 0) {
          return [];
        }
        
        // Detecta índices das colunas
        const valueCol = field.optionsValueColumn || null;
        const labelCol = field.optionsLabelColumn || null;
        
        // Tenta detectar cabeçalhos na primeira linha
        let startIndex = 0;
        let valueIndex = 0;
        let labelIndex = 1;
        
        if (resultado.data.length > 0 && Array.isArray(resultado.data[0])) {
          const firstRow = resultado.data[0];
          
          // Verifica se primeira linha parece ser cabeçalho
          const isHeader = firstRow.some(cell => typeof cell === 'string' && cell.toUpperCase() === cell);
          
          if (isHeader) {
            // Mapeia índices pelos nomes das colunas
            firstRow.forEach((colName, idx) => {
              const colUpper = String(colName).toUpperCase();
              if (valueCol && colUpper === valueCol.toUpperCase()) {
                valueIndex = idx;
              }
              if (labelCol && colUpper === labelCol.toUpperCase()) {
                labelIndex = idx;
              }
            });
            startIndex = 1; // Pula cabeçalho
          } else {
            // Se não tem cabeçalho, usa índices padrão ou busca por nome
            if (valueCol || labelCol) {
              // Se especificou nomes mas não tem cabeçalho, assume ordem padrão
              valueIndex = 0;
              labelIndex = 1;
            }
          }
        }
        
        // Mapeia resultados para formato {value, label}
        const options = [];
        for (let i = startIndex; i < resultado.data.length; i++) {
          const row = resultado.data[i];
          if (!Array.isArray(row) || row.length === 0) continue;
          
          const value = String(row[valueIndex] ?? row[0] ?? '');
          const label = String(row[labelIndex] ?? row[1] ?? value);
          
          if (value) {
            options.push({ value, label });
          }
        }
        
        return options;
      } catch (error) {
        console.error(`Erro ao executar query de opções para campo ${field.id}:`, error);
        throw error;
      }
    }

    /**
     * Renderiza campo select
     * @param {Object} field - Configuração do campo
     * @param {Array} options - Array de opções no formato {value, label} (opcional, usa field.options se não fornecido)
     */
    function renderSelectField(field, options = null) {
      const value = filterValues[field.id] || '';
      
      // Usa opções fornecidas ou fallback para field.options
      const fieldOptions = options !== null ? options : (field.options || []);
      
      let optionsHtml = '<option value="">Selecione...</option>';
      
      if (fieldOptions && fieldOptions.length > 0) {
        optionsHtml += fieldOptions.map(opt => 
          `<option value="${String(opt.value)}" ${String(opt.value) === value ? 'selected' : ''}>${String(opt.label)}</option>`
        ).join('');
      }
      
      return `
        <div class="space-y-2">
          <label class="block text-sm font-medium text-slate-700">${field.label}</label>
          <select
            id="filter-${field.id}"
            data-field-type="select"
            data-variable="${field.variable}"
            class="w-full px-3 py-2 border border-slate-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-1 focus:border-transparent transition-all duration-200"
          >
            ${optionsHtml}
          </select>
        </div>
      `;
    }

    /**
     * Renderiza campo multiselect (múltipla seleção com busca)
     * @param {Object} field - Configuração do campo
     * @param {Array} options - Array de opções no formato {value, label}
     */
    function renderMultiSelectField(field, options = []) {
      const savedValues = (filterValues[field.id] || '').split(',').filter(v => v);
      const placeholder = field.placeholder || 'Buscar e selecionar...';
      
      // Gera HTML das opções
      let optionsHtml = '';
      if (options && options.length > 0) {
        optionsHtml = options.map(opt => {
          const value = String(opt.value);
          const label = String(opt.label);
          const checked = savedValues.includes(value);
          const searchText = label.toLowerCase();
          
          return `
            <div class="multiselect-option" data-search-text="${searchText}" data-value="${value}">
              <input
                type="checkbox"
                id="multiselect-${field.id}-${value}"
                value="${value}"
                ${checked ? 'checked' : ''}
                onchange="handleMultiSelectChange('${field.id}', this)"
              />
              <label for="multiselect-${field.id}-${value}">${label}</label>
            </div>
          `;
        }).join('');
      } else {
        optionsHtml = '<div class="multiselect-empty">Nenhuma opção disponível</div>';
      }
      
      // Gera HTML das tags (itens selecionados)
      let tagsHtml = '';
      let displayPlaceholder = placeholder;
      if (savedValues.length > 0) {
        const selectedOptions = options.filter(opt => savedValues.includes(String(opt.value)));
        tagsHtml = selectedOptions.map(opt => {
          const value = String(opt.value);
          const label = String(opt.label);
          return `
            <span class="multiselect-tag">
              ${label}
              <span class="multiselect-tag-remove" onclick="removeMultiSelectTag('${field.id}', '${value}')" title="Remover">×</span>
            </span>
          `;
        }).join('');
        
        // Define placeholder baseado na quantidade de seleções
        if (selectedOptions.length === 1) {
          // Se há apenas uma seleção, mostra o nome da opção
          displayPlaceholder = selectedOptions[0].label;
        } else if (selectedOptions.length > 1) {
          // Se há múltiplas seleções, mostra "várias"
          displayPlaceholder = `${selectedOptions.length} selecionadas`;
        }
      }
      
      return `
        <div class="space-y-2">
          <label class="block text-sm font-medium text-slate-700">${field.label}</label>
          <div class="multiselect-container">
            <div class="multiselect-trigger" onclick="toggleMultiSelect('${field.id}')">
              <input
                type="text"
                id="multiselect-search-${field.id}"
                class="multiselect-search-input"
                placeholder="${displayPlaceholder}"
                oninput="filterMultiSelectOptions('${field.id}', this.value)"
                onclick="event.stopPropagation(); toggleMultiSelect('${field.id}')"
                onfocus="toggleMultiSelect('${field.id}')"
              />
              <svg class="multiselect-chevron" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
              </svg>
            </div>
            <div id="multiselect-dropdown-${field.id}" class="multiselect-dropdown hidden">
              <div id="multiselect-options-${field.id}" class="multiselect-options">
                ${optionsHtml}
              </div>
            </div>
          </div>
          <div id="multiselect-tags-${field.id}" class="multiselect-tags">
            ${tagsHtml}
          </div>
        </div>
      `;
    }

    /**
     * Sistema de Multiselect - Funções de Interação
     */

    // Debounce para busca
    let multiselectSearchTimeouts = {};

    /**
     * Alterna estado aberto/fechado do dropdown multiselect
     * @param {string} fieldId - ID do campo multiselect
     */
    function toggleMultiSelect(fieldId) {
      const dropdown = document.getElementById(`multiselect-dropdown-${fieldId}`);
      const trigger = document.querySelector(`#multiselect-search-${fieldId}`).closest('.multiselect-trigger');
      
      if (!dropdown || !trigger) return;
      
      const isOpen = !dropdown.classList.contains('hidden');
      
      // Fecha todos os outros multiselects abertos
      document.querySelectorAll('.multiselect-dropdown').forEach(dd => {
        if (dd.id !== `multiselect-dropdown-${fieldId}`) {
          dd.classList.add('hidden');
          const otherTrigger = dd.previousElementSibling;
          if (otherTrigger && otherTrigger.classList.contains('multiselect-trigger')) {
            otherTrigger.classList.remove('open');
          }
        }
      });
      
      // Toggle do dropdown atual
      if (isOpen) {
        dropdown.classList.add('hidden');
        trigger.classList.remove('open');
      } else {
        dropdown.classList.remove('hidden');
        trigger.classList.add('open');
        // Foca no input de busca
        const searchInput = document.getElementById(`multiselect-search-${fieldId}`);
        if (searchInput) {
          setTimeout(() => searchInput.focus(), 50);
        }
      }
    }

    /**
     * Filtra opções do multiselect baseado no termo de busca
     * @param {string} fieldId - ID do campo multiselect
     * @param {string} searchTerm - Termo de busca
     */
    function filterMultiSelectOptions(fieldId, searchTerm) {
      // Limpa timeout anterior para este campo
      if (multiselectSearchTimeouts[fieldId]) {
        clearTimeout(multiselectSearchTimeouts[fieldId]);
      }
      
      // Debounce de 100ms para melhorar performance
      multiselectSearchTimeouts[fieldId] = setTimeout(() => {
        const optionsContainer = document.getElementById(`multiselect-options-${fieldId}`);
        if (!optionsContainer) return;
        
        const searchLower = searchTerm.toLowerCase().trim();
        const options = optionsContainer.querySelectorAll('.multiselect-option');
        
        let visibleCount = 0;
        options.forEach(option => {
          const searchText = option.getAttribute('data-search-text') || '';
          const matches = !searchLower || searchText.includes(searchLower);
          
          if (matches) {
            option.classList.remove('hidden');
            visibleCount++;
          } else {
            option.classList.add('hidden');
          }
        });
        
        // Mostra mensagem se não houver resultados
        let emptyMsg = optionsContainer.querySelector('.multiselect-empty-search');
        if (visibleCount === 0 && searchLower) {
          if (!emptyMsg) {
            emptyMsg = document.createElement('div');
            emptyMsg.className = 'multiselect-empty-search multiselect-empty';
            emptyMsg.textContent = 'Nenhuma opção encontrada';
            optionsContainer.appendChild(emptyMsg);
          }
        } else if (emptyMsg) {
          emptyMsg.remove();
        }
      }, 100);
    }

    /**
     * Manipula mudança de checkbox no multiselect
     * @param {string} fieldId - ID do campo multiselect
     * @param {HTMLInputElement} checkbox - Checkbox que foi alterado
     */
    function handleMultiSelectChange(fieldId, checkbox) {
      updateMultiSelectTags(fieldId);
      // Mantém dropdown aberto após seleção
      const dropdown = document.getElementById(`multiselect-dropdown-${fieldId}`);
      if (dropdown) {
        dropdown.classList.remove('hidden');
      }
    }

    /**
     * Remove uma tag específica do multiselect
     * @param {string} fieldId - ID do campo multiselect
     * @param {string} value - Valor da opção a ser removida
     */
    function removeMultiSelectTag(fieldId, value) {
      const checkbox = document.getElementById(`multiselect-${fieldId}-${value}`);
      if (checkbox) {
        checkbox.checked = false;
        updateMultiSelectTags(fieldId);
      }
    }

    /**
     * Atualiza display das tags (itens selecionados) do multiselect
     * @param {string} fieldId - ID do campo multiselect
     */
    function updateMultiSelectTags(fieldId) {
      const optionsContainer = document.getElementById(`multiselect-options-${fieldId}`);
      const tagsContainer = document.getElementById(`multiselect-tags-${fieldId}`);
      const searchInput = document.getElementById(`multiselect-search-${fieldId}`);
      
      if (!optionsContainer || !tagsContainer) return;
      
      // Coleta checkboxes marcados
      const checkboxes = optionsContainer.querySelectorAll('input[type="checkbox"]:checked');
      const selectedValues = Array.from(checkboxes).map(cb => cb.value);
      
      // Atualiza filterValues
      filterValues[fieldId] = selectedValues.join(',');
      
      // Coleta labels das opções selecionadas
      const selectedOptions = [];
      checkboxes.forEach(checkbox => {
        const optionDiv = checkbox.closest('.multiselect-option');
        if (optionDiv) {
          const label = optionDiv.querySelector('label');
          if (label) {
            selectedOptions.push({
              value: checkbox.value,
              label: label.textContent.trim()
            });
          }
        }
      });
      
      // Renderiza tags
      if (selectedOptions.length > 0) {
        tagsContainer.innerHTML = selectedOptions.map(opt => `
          <span class="multiselect-tag">
            ${opt.label}
            <span class="multiselect-tag-remove" onclick="removeMultiSelectTag('${fieldId}', '${opt.value}')" title="Remover">×</span>
          </span>
        `).join('');
        
        // Atualiza placeholder do input baseado na quantidade de seleções
        if (searchInput) {
          if (selectedOptions.length === 1) {
            // Se há apenas uma seleção, mostra o nome da opção
            searchInput.placeholder = selectedOptions[0].label;
          } else {
            // Se há múltiplas seleções, mostra "várias"
            searchInput.placeholder = `${selectedOptions.length} selecionadas`;
          }
        }
      } else {
        tagsContainer.innerHTML = '';
        // Restaura placeholder padrão
        if (searchInput) {
          const config = getFilterConfig();
          if (config) {
            const field = config.fields.find(f => f.id === fieldId);
            if (field) {
              searchInput.placeholder = field.placeholder || 'Buscar e selecionar...';
            }
          }
        }
      }
    }

    /**
     * Renderiza campo checkbox (múltipla seleção)
     */
    function renderCheckboxField(field) {
      const values = (filterValues[field.id] || '').split(',').filter(v => v);
      
      let checkboxesHtml = '';
      if (field.options) {
        checkboxesHtml = field.options.map(opt => {
          const checked = values.includes(opt.value);
          return `
            <label class="flex items-center space-x-2 cursor-pointer hover:bg-slate-50 rounded-md p-1 transition-colors duration-150">
              <input
                type="checkbox"
                value="${opt.value}"
                data-field-id="${field.id}"
                data-variable="${field.variable}"
                ${checked ? 'checked' : ''}
                class="w-4 h-4 text-blue-600 border-slate-300 rounded focus:ring-2 focus:ring-blue-500 focus:ring-offset-1"
              />
              <span class="text-sm text-slate-700">${opt.label}</span>
            </label>
          `;
        }).join('');
      }
      
      return `
        <div class="space-y-2">
          <label class="block text-sm font-medium text-slate-700">${field.label}</label>
          <div class="space-y-2" data-field-type="checkbox" data-field-id="${field.id}" data-variable="${field.variable}">
            ${checkboxesHtml}
          </div>
        </div>
      `;
    }

    /**
     * Renderiza campo de período (date range)
     */
    function renderDateRangeField(field) {
      const startValue = filterValues[`${field.id}_start`] || '';
      const endValue = filterValues[`${field.id}_end`] || '';
      
      return `
        <div class="space-y-2">
          <label class="block text-sm font-medium text-slate-700">${field.label}</label>
          <div class="grid grid-cols-2 gap-2">
            <div>
              <label class="block text-xs text-slate-500 mb-1">Início</label>
              <input
                type="date"
                id="filter-${field.id}_start"
                data-field-type="dateRange"
                data-variable-start="${field.variableStart}"
                value="${startValue}"
                class="w-full px-3 py-2 border border-slate-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-1 focus:border-transparent transition-all duration-200"
              />
            </div>
            <div>
              <label class="block text-xs text-slate-500 mb-1">Fim</label>
              <input
                type="date"
                id="filter-${field.id}_end"
                data-field-type="dateRange"
                data-variable-end="${field.variableEnd}"
                value="${endValue}"
                class="w-full px-3 py-2 border border-slate-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-1 focus:border-transparent transition-all duration-200"
              />
            </div>
          </div>
        </div>
      `;
    }

    /**
     * Renderiza campo de ano (dropdown)
     * @param {Object} field - Configuração do campo
     * @param {Array} options - Array de opções no formato {value, label}
     */
    function renderYearField(field, options = null) {
      const value = filterValues[field.id] || '';
      
      const fieldOptions = options !== null ? options : (field.options || []);
      
      let optionsHtml = '<option value="">Selecione o ano...</option>';
      
      if (fieldOptions && fieldOptions.length > 0) {
        optionsHtml += fieldOptions.map(opt => 
          `<option value="${String(opt.value)}" ${String(opt.value) === value ? 'selected' : ''}>${String(opt.label)}</option>`
        ).join('');
      }
      
      return `
        <div class="space-y-2">
          <label class="block text-sm font-medium text-slate-700">${field.label}</label>
          <select
            id="filter-${field.id}"
            data-field-type="year"
            data-variable="${field.variable}"
            class="w-full px-3 py-2 border border-slate-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-1 focus:border-transparent transition-all duration-200"
          >
            ${optionsHtml}
          </select>
        </div>
      `;
    }

    /**
     * Renderiza campo de mês (dropdown com opções estáticas 01-12)
     * @param {Object} field - Configuração do campo
     */
    function renderMonthField(field) {
      const value = filterValues[field.id] || '';
      
      // Opções fixas de meses (01 a 12)
      const months = [
        { value: '01', label: '01' },
        { value: '02', label: '02' },
        { value: '03', label: '03' },
        { value: '04', label: '04' },
        { value: '05', label: '05' },
        { value: '06', label: '06' },
        { value: '07', label: '07' },
        { value: '08', label: '08' },
        { value: '09', label: '09' },
        { value: '10', label: '10' },
        { value: '11', label: '11' },
        { value: '12', label: '12' }
      ];
      
      let optionsHtml = '<option value="">Selecione o mês...</option>';
      optionsHtml += months.map(opt => 
        `<option value="${opt.value}" ${opt.value === value ? 'selected' : ''}>${opt.label}</option>`
      ).join('');
      
      return `
        <div class="space-y-2">
          <label class="block text-sm font-medium text-slate-700">${field.label}</label>
          <select
            id="filter-${field.id}"
            data-field-type="month"
            data-variable="${field.variable}"
            class="w-full px-3 py-2 border border-slate-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-1 focus:border-transparent transition-all duration-200"
          >
            ${optionsHtml}
          </select>
        </div>
      `;
    }

    /**
     * Coleta valores dos campos de filtro do DOM
     * @returns {Array} Array de objetos {name, content} para setVariableMitra
     */
    function collectFilterValues() {
      const config = getFilterConfig();
      if (!config) return [];
      
      const variablesToSet = [];
      
      config.fields.forEach(field => {
        switch (field.type) {
          case 'text':
            const textInput = document.getElementById(`filter-${field.id}`);
            if (textInput) {
              const value = textInput.value.trim();
              filterValues[field.id] = value;
              if (value) {
                variablesToSet.push({ name: field.variable, content: value });
              }
            }
            break;
            
          case 'select':
            const selectInput = document.getElementById(`filter-${field.id}`);
            if (selectInput) {
              const value = selectInput.value;
              filterValues[field.id] = value;
              if (value) {
                variablesToSet.push({ name: field.variable, content: value });
              }
            }
            break;
            
          case 'multiselect':
            const multiselectCheckboxes = document.querySelectorAll(
              `#multiselect-options-${field.id} input[type="checkbox"]:checked`
            );
            const multiselectValues = Array.from(multiselectCheckboxes).map(cb => cb.value).filter(v => v);
            const multiselectValue = multiselectValues.join(',');
            filterValues[field.id] = multiselectValue;
            if (multiselectValue) {
              variablesToSet.push({ name: field.variable, content: multiselectValue });
            }
            break;
            
          case 'checkbox':
            const checkboxes = document.querySelectorAll(`input[type="checkbox"][data-field-id="${field.id}"]:checked`);
            const checkedValues = Array.from(checkboxes).map(cb => cb.value).filter(v => v);
            const checkboxValue = checkedValues.join(',');
            filterValues[field.id] = checkboxValue;
            if (checkboxValue) {
              variablesToSet.push({ name: field.variable, content: checkboxValue });
            }
            break;
            
          case 'dateRange':
            const startInput = document.getElementById(`filter-${field.id}_start`);
            const endInput = document.getElementById(`filter-${field.id}_end`);
            if (startInput && endInput) {
              const startValue = startInput.value;
              const endValue = endInput.value;
              filterValues[`${field.id}_start`] = startValue;
              filterValues[`${field.id}_end`] = endValue;
              if (startValue) {
                variablesToSet.push({ name: field.variableStart, content: startValue });
              }
              if (endValue) {
                variablesToSet.push({ name: field.variableEnd, content: endValue });
              }
            }
            break;
          case 'year':
            const yearInput = document.getElementById(`filter-${field.id}`);
            if (yearInput) {
              const value = yearInput.value;
              filterValues[field.id] = value;
              if (value) {
                variablesToSet.push({ name: field.variable, content: value });
              }
            }
            break;
          case 'month':
            const monthInput = document.getElementById(`filter-${field.id}`);
            if (monthInput) {
              const value = monthInput.value;
              filterValues[field.id] = value;
              if (value) {
                variablesToSet.push({ name: field.variable, content: value });
              }
            }
            break;
        }
      });
      
      return variablesToSet;
    }

    /**
     * Define variáveis Mitra a partir de um array de variáveis
     * @param {Array} variables Array de objetos {name, content}
     */
    async function setFilterVariables(variables) {
      for (const variable of variables) {
        await setVariableMitra(variable);
      }
    }

    /**
     * Busca o valor de uma variável Mitra usando queryMitra
     * @param {string} variableName Nome da variável (ex: ':VAR_FILTRO_EMPRESA')
     * @returns {Promise<string|null>} Valor da variável ou null se não existir/vazio
     */
    async function fetchVariableValue(variableName) {
      try {
        const query = `SELECT ${variableName} as value FROM dual`;
        const resultado = await queryMitra(query);
        
        // Verifica se há resultado e se tem dados
        if (!resultado || !resultado.data || resultado.data.length === 0) {
          return null;
        }
        
        // Pega o primeiro valor da primeira linha
        const value = resultado.data[0][0];
        
        // Retorna null se o valor for null, undefined ou string vazia
        if (value === null || value === undefined || value === '') {
          return null;
        }
        
        // Converte para string e retorna
        return String(value);
      } catch (error) {
        // Ignora silenciosamente erros ao buscar variáveis individuais
        return null;
      }
    }

    /**
     * Carrega valores salvos das variáveis Mitra e popula filterValues
     */
    async function loadFilterValues() {
      const config = getFilterConfig();
      if (!config) return;
      
      // Para cada campo, busca o valor da variável correspondente
      for (const field of config.fields) {
        try {
          switch (field.type) {
            case 'text':
            case 'select':
            case 'year':
            case 'month':
              if (field.variable) {
                const value = await fetchVariableValue(field.variable);
                if (value !== null) {
                  filterValues[field.id] = value;
                }
              }
              break;
              
            case 'multiselect':
            case 'checkbox':
              if (field.variable) {
                const value = await fetchVariableValue(field.variable);
                if (value !== null) {
                  filterValues[field.id] = value;
                }
              }
              break;
              
            case 'dateRange':
              if (field.variableStart) {
                const startValue = await fetchVariableValue(field.variableStart);
                if (startValue !== null) {
                  filterValues[`${field.id}_start`] = startValue;
                }
              }
              if (field.variableEnd) {
                const endValue = await fetchVariableValue(field.variableEnd);
                if (endValue !== null) {
                  filterValues[`${field.id}_end`] = endValue;
                }
              }
              break;
          }
        } catch (error) {
          // Ignora silenciosamente erros ao buscar variáveis individuais
          // Continua processando os outros campos
        }
      }
    }

    /**
     * Aplica filtros e define variáveis Mitra
     */
    async function applyFilters() {
      const config = getFilterConfig();
      if (!config) return;
      
      try {
        // Coleta valores dos campos
        const variablesToSet = collectFilterValues();
        
        // Define todas as variáveis Mitra
        await setFilterVariables(variablesToSet);
        
        // Recarrega a tela atual
        await reloadCurrentScreen();
        
        updateFilterBadge();
        closeFilterModal();
      } catch (error) {
        console.error('Erro ao aplicar filtros:', error);
      }
    }

    /**
     * Coleta todas as variáveis para limpar (retorna array vazio para cada variável)
     * @returns {Array} Array de objetos {name, content: ''} para limpar variáveis
     */
    function collectFilterVariablesToClear() {
      const config = getFilterConfig();
      if (!config) return [];
      
      const variablesToClear = [];
      
      config.fields.forEach(field => {
        switch (field.type) {
          case 'text':
          case 'select':
            variablesToClear.push({ name: field.variable, content: '' });
            filterValues[field.id] = '';
            break;
          case 'multiselect':
            variablesToClear.push({ name: field.variable, content: '' });
            filterValues[field.id] = '';
            // Desmarca todos os checkboxes
            const multiselectCheckboxes = document.querySelectorAll(
              `#multiselect-options-${field.id} input[type="checkbox"]`
            );
            multiselectCheckboxes.forEach(cb => cb.checked = false);
            // Atualiza tags
            updateMultiSelectTags(field.id);
            break;
          case 'checkbox':
            variablesToClear.push({ name: field.variable, content: '' });
            filterValues[field.id] = '';
            break;
          case 'dateRange':
            variablesToClear.push({ name: field.variableStart, content: '' });
            variablesToClear.push({ name: field.variableEnd, content: '' });
            filterValues[`${field.id}_start`] = '';
            filterValues[`${field.id}_end`] = '';
            break;
          case 'year':
            variablesToClear.push({ name: field.variable, content: '' });
            filterValues[field.id] = '';
            break;
          case 'month':
            variablesToClear.push({ name: field.variable, content: '' });
            filterValues[field.id] = '';
            break;
        }
      });
      
      return variablesToClear;
    }

    /**
     * Limpa todos os filtros
     */
    async function clearFilters() {
      const config = getFilterConfig();
      if (!config) return;
      
      try {
        // Coleta todas as variáveis para limpar
        const variablesToClear = collectFilterVariablesToClear();
        
        // Limpa variáveis Mitra
        await setFilterVariables(variablesToClear);
        
        // Recarrega campos
        await loadFilterFields();
        updateFilterBadge();
        
        // Recarrega a tela atual
        await reloadCurrentScreen();
      } catch (error) {
        console.error('Erro ao limpar filtros:', error);
      }
    }

    /**
     * Atualiza badge com quantidade de filtros ativos
     */
    function updateFilterBadge() {
      const badge = domCache.get('filter-badge');
      if (!badge) return;
      
      let activeCount = 0;
      const config = getFilterConfig();
      
      if (config) {
        config.fields.forEach(field => {
          switch (field.type) {
            case 'text':
            case 'select':
              if (filterValues[field.id]) activeCount++;
              break;
            case 'multiselect':
              if (filterValues[field.id]) activeCount++;
              break;
            case 'checkbox':
              if (filterValues[field.id]) activeCount++;
              break;
            case 'dateRange':
              if (filterValues[`${field.id}_start`] || filterValues[`${field.id}_end`]) activeCount++;
              break;
            case 'year':
              if (filterValues[field.id]) activeCount++;
              break;
            case 'month':
              if (filterValues[field.id]) activeCount++;
              break;
          }
        });
      }
      
      if (activeCount > 0) {
        badge.textContent = activeCount;
        badge.classList.remove('hidden');
      } else {
        badge.classList.add('hidden');
      }
    }

    // Inicializa quando o DOM estiver pronto
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        initializeSidebar();
        loadFilterConfig();
      });
    } else {
      initializeSidebar();
      loadFilterConfig();
    }
  </script>
</body>
</html>
